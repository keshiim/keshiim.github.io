<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Farmer, keshiim 播种太阳🌞" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="一个☝程序猿的播种天地">
<meta property="og:type" content="website">
<meta property="og:title" content="Farmer, keshiim 播种太阳🌞">
<meta property="og:url" content="https://keshiim.github.io/page/4/index.html">
<meta property="og:site_name" content="Farmer, keshiim 播种太阳🌞">
<meta property="og:description" content="一个☝程序猿的播种天地">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Farmer, keshiim 播种太阳🌞">
<meta name="twitter:description" content="一个☝程序猿的播种天地">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://keshiim.github.io/page/4/"/>





  <title>Farmer, keshiim 播种太阳🌞</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?921c9b00f7bef5665a875398ea470185";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Farmer, keshiim 播种太阳🌞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小n快乐成长🍉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keshiim.github.io/2017/11/10/Swift-Enum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng keshiim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Farmer, keshiim 播种太阳🌞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/10/Swift-Enum/" itemprop="url">Swift：枚举</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-10T18:53:11+08:00">
                2017-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/10/Swift-Enum/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/10/Swift-Enum/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/11/10/Swift-Enum/" class="leancloud_visitors" data-flag-title="Swift：枚举">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>枚举为一组相关值定义了一个通用类型，从而可以让你在代码中类型安全地操作这些值。</p>
<p>如果你熟悉 C ，那么你可能知道 C 中的枚举会给一组<code>整数值</code>分配相关的名称。Swift 中的枚举则更加灵活，并且不需给枚举中的每一个成员都提供值。如果一个值（所谓“原始”值）要被提供给每一个枚举成员，那么这个值可以是<code>字符串</code>、<code>字符</code>、<code>任意的整数值</code>，或者是<code>浮点类型</code>。</p>
<p>而且，<em>枚举成员</em>可以指定<strong>任意类型</strong>的值来与<em>不同的成员值关联储存</em>，这更像是其他语言中的 union 或variant 的效果。你可以定义一组相关成员的合集作为枚举的一部分，每一个成员都可以有不同类型的值的合集与其关联。</p>
<p>Swift 中的枚举是具有自己<em>权限的一类类型</em>。它们使用了许多一般只被类所支持的特性，例如<strong>计算属性</strong>用来提供关于枚举当前值的额外信息，并且<strong>实例方法</strong>用来提供与枚举表示的值相关的功能。枚举同样也能够<strong>定义初始化器</strong>来初始化成员值；而且能够<strong>遵循协议</strong>来提供标准功能。(🐂吧？)</p>
<h3 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h3><p>你可以用 <code>enum</code>关键字来定义一个枚举，然后将其所有的定义内容放在一个大括号（<code>{}</code>）中</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</div><div class="line">    <span class="comment">// enumeration definition goes here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个指南针的四个主要方向的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> north</div><div class="line">    <span class="keyword">case</span> south</div><div class="line">    <span class="keyword">case</span> east</div><div class="line">    <span class="keyword">case</span> west</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在一个枚举中定义的值（比如： north， south， east和 west）就是枚举的<em>成员值</em>（或成员） <code>case</code><strong>关键字则明确了要定义成员值</strong>。</p>
<blockquote>
<p>不像 C 和 Objective-C 那样，Swift 的枚举成员在被创建时<strong>不会分配一个默认的整数值</strong>。在上文的 <code>CompassPoint</code>例子中， <code>north</code>， <code>south</code>， <code>east</code>和 <code>west</code>并不代表 0， 1， 2和 3。而相反，不同的枚举成员在它们自己的权限中都是<em>完全合格</em>的值，并且是一个在 CompassPoint中被显式定义的类型。</p>
</blockquote>
<p>多个成员值可以出现在同一行中，要用逗号隔开：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> </span>&#123;</div><div class="line">    <span class="comment">//行星</span></div><div class="line">    <span class="keyword">case</span> mercury, venus, earth, mars, jupiter, saturn, uranus, neptune</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如 Swift 中其它的类型那样，它们的名称（例如： <code>CompassPoint</code>和 <code>Planet</code>）需要<strong>首字母大写</strong>。给枚举类型起一个单数的而不是复数的名字，从而使得它们能够顾名思义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> directionToHead = <span class="type">CompassPoint</span>.west</div></pre></td></tr></table></figure>
<p>好玩的语法：当与 <code>CompassPoint</code>中可用的某一值一同初始化时 <code>directionToHead</code>的类型会被推断出来。一旦 <code>directionToHead</code>以 <code>CompassPoint</code>类型被声明，你就可以用一个点语法把它设定成不同的 <code>CompassPoint</code>值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">directionToHead = .east <span class="comment">//东</span></div></pre></td></tr></table></figure>
<h3 id="使用-Switch-语句来匹配枚举值"><a href="#使用-Switch-语句来匹配枚举值" class="headerlink" title="使用 Switch 语句来匹配枚举值"></a>使用 Switch 语句来匹配枚举值</h3><p>用 <code>switch</code>语句来匹配每一个单独的枚举值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> directionToHead &#123;</div><div class="line"><span class="keyword">case</span> .north:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Lots of planets have a north"</span>)</div><div class="line"><span class="keyword">case</span> .south:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Watch out for penguins"</span>)</div><div class="line"><span class="keyword">case</span> .east:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Where the sun rises"</span>)</div><div class="line"><span class="keyword">case</span> .west:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Where the skies are blue"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//print Where the sun rises</span></div></pre></td></tr></table></figure>
<p>正如在控制流中所描述的那样，当判断一个枚举成员时， <code>switch</code>语句应该是全覆盖的。如果 <code>.west</code>的 <code>case</code>被省略了，那么<em>代码将不能编译</em>，因为这时表明它并没有覆盖 <code>CompassPoint</code>的所有成员。要求覆盖所有枚举成员是因为这样可以保证枚举成员不会意外的被漏掉。</p>
<p>否者，使用<code>default</code>情况来包含那些不被显示明确写出的成员：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> somePlanet = <span class="type">Planet</span>.earth</div><div class="line"><span class="keyword">switch</span> somePlanet &#123;</div><div class="line"><span class="keyword">case</span> .earth:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Mostly harmless"</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Not a safe place for humans"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Prins "Mossly harmless"</span></div></pre></td></tr></table></figure>
<h3 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h3><p>上面的栗子展示了枚举成员是怎样在他们各自的权限中被<em>定义</em>（和被分类）的。你可以给 <code>Planet.earth</code>设定常量或变量，然后再使用这个值。总之，<strong>有时将其它类型的关联值与这些成员值一起存储是很有用的</strong>。这样你就可以将额外的<em>自定义信息</em>和<em>成员值</em>一起储存，并且允许你在代码中使用每次调用这个成员时都能使用它。</p>
<p>你可以定义 Swift 枚举来存储任意给定类型的关联值，如果需要的话不同枚举成员关联值的类型可以不同。</p>
<p>举个栗子，假设库存跟踪系统需要按两个不同类型的条形码跟踪产品，一些产品贴的是用数字 <code>0~9</code> 的 <code>UPC-A</code> 格式一维条形码。每一个条码数字都含有一个“数字系统”位，之后是五个“制造商代码”数字和五个“产品代码”数字。而最后则是一个“检测”位来验证代码已经被正确扫描：<br><img style="margin: auto" src="/2017/11/10/Swift-Enum/barcode_UPC_2x.png" alt="barcode_UPC_2x" title="条形码示例"><br>其它的产品则贴着二维码，它可以使用任何 <code>ISO 8859-1</code> 字符并且编码最长有 <code>2953</code> 个字符的字符串：<br><img style="margin: auto" src="/2017/11/10/Swift-Enum/barcode_QR_2x.png" alt="barcode_QR_2x" title="二维码示例"><br>这样可以让库存跟踪系统很方便的以一个由 4 个整数组成的元组来储存 <code>UPC-A</code> 条形码，然而二维码则可以被存储为一个任意长度的字符串中。</p>
<p>在 Swift 中，为不同类型产品条码定义枚举大概是这种姿势：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</div><div class="line">    <span class="comment">//关联值</span></div><div class="line">    <span class="keyword">case</span> upc(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</div><div class="line">    <span class="keyword">case</span> qrCode(<span class="type">String</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这可以读作：</p>
<p>“<em>定义一个叫做 <code>Barcode</code>的枚举类型，它要么用 <code>(Int, Int, Int, Int)</code>类型的关联值获取 <code>upc</code> 值，要么用 <code>String</code> 类型的关联值获取一个 <code>qrCode</code>的值。</em>”</p>
<p>这个定义并不提供任何实际的 <code>Int</code>或者 <code>String</code>的值——它只定义当 <code>Barcode</code>常量和变量与 <code>Barcode. upc</code>或 <code>Barcode. qrCode</code><strong>相同时可以存储的关联值的类型</strong>。</p>
<p>新的条码就可以用任意一个类型来创建了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> productBarcode = <span class="type">Barcode</span>.upc(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>这个栗子创建了一个叫做 <code>productBarcode</code>的新变量而且给它赋值了一个 <code>Barcode.upc的值</code><em>关联了</em>值为 <code>(8, 85909, 51226, 3)</code>的<em>元组值</em>。</p>
<p>同样的产品可以被分配一个不同类型的条码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">productBarcode = .qrCode(<span class="string">"ABCDEFGHIJKLMNOP"</span>)</div></pre></td></tr></table></figure>
<p>这时，最初的 <code>Barcode.upc</code>和它的整数值将被新的 <code>Barcode.qrCode</code>和它的字符串值代替。 <code>Barcode</code>类型的常量和变量可以存储一个 <code>.upc</code>或一个 <code>.qrCode</code>（和它们的相关值一起存储）中的任意一个，但是它们只可以在给定的时间内存储它们其中之一。</p>
<p>不同的条码类型可以用 <code>switch</code> 语句来检查。这一次，总之，相关值可以被提取为 <code>switch</code> 语句的一部分。你提取的每一个相关值都可以作为常量（用 <code>let</code>前缀) 或者变量（用 <code>var</code>前缀）在 <code>switch</code>的 <code>case</code>中使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> productBarcode &#123;</div><div class="line"><span class="keyword">case</span> .upc(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> manufacturer, <span class="keyword">let</span> product, <span class="keyword">let</span> check):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"UPC: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>."</span>)</div><div class="line"><span class="keyword">case</span> .qrCode(<span class="keyword">let</span> productCode):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"QR code: <span class="subst">\(productCode)</span>."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Prints "QR code: ABCDEFGHIJKLMNOP."</span></div></pre></td></tr></table></figure>
<p>如果对于一个枚举成员的所有的相关值<strong>都</strong>被提取为<em>常量</em>，或如果<strong>都</strong>被提取为<em>变量</em>，为了简洁，你可以用一个单独的 <code>var</code>或 <code>let</code>在成员名称前标注：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> productBarcode &#123;</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> .upc(numberSystem, manufacturer, product, check):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"UPC : <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>."</span>)</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> .qrCode(productCode):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"QR code: <span class="subst">\(productCode)</span>."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Prints "QR code: ABCDEFGHIJKLMNOP."</span></div></pre></td></tr></table></figure>
<h3 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h3><p><em>关联值</em> 中条形码的栗子展示了枚举成员是如何声明它们存储不同类型的相关值的。作为相关值的另一种选择，<em>枚举成员</em>可以用<strong>相同类型的默认值</strong>预先填充（称为<em>原始值</em>）。</p>
<p>这里有一个和已命名的枚举成员一起存储的原始 ASCII 码的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> tab = <span class="string">"\t"</span></div><div class="line">    <span class="keyword">case</span> lineFeed = <span class="string">"\n"</span></div><div class="line">    <span class="keyword">case</span> carriageReturn = <span class="string">"\r"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，一个叫做 <code>ASCIIControlCharacter</code>的枚举原始值被定义为类型 <code>Character</code>，并且被放置在了更多的一些 <code>ASCII</code> 控制字符中。</p>
<blockquote>
<p>注意：原始值与关联值不同。原始值是当你第一次定义枚举的时候，它们用来预先填充的值，正如上面的三个 ASCII 码。特定枚举成员的<strong>原始值是始终相同的</strong>。<strong>关联值</strong>在你基于枚举成员的其中之一<strong>创建新的常量或变量时</strong>设定，并且在你每次这么做的时候这些关联值可以是<em>不同的</em>。</p>
</blockquote>
<h4 id="隐式指定的原始值"><a href="#隐式指定的原始值" class="headerlink" title="隐式指定的原始值"></a>隐式指定的原始值</h4><p>当你在操作存储整数或字符串原始值枚举的时候， <em>你不必显式地给每一个成员都分配一个原始值</em> 。当你没有分配时，Swift <em>将会自动为你分配值</em>。</p>
<p>实际上，当整数值被用于作为原始值时，每成员的隐式值都<em>比前一个大一</em>。如果第一个成员没有值，那么它的值是 <code>0</code>。</p>
<p>下面的枚举是先前的 <code>Planet</code>枚举的简化，用整数原始值来代表从太阳到每一个行星的顺序：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> mercury = <span class="number">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此🌰：<code>Planet.mercury</code>有一个明确的原始值 <code>1</code> ， <code>Planet.venus</code>的隐式原始值是 <code>2</code>，以此类推。</p>
<p>当<em>字符串</em>被用于原始值，那么每一个成员的<em>隐式原始值</em>则是那个成员的<strong>名称</strong>。</p>
<p>下面的枚举是先前 <code>CompassPoint</code>枚举的简化，有<em>字符串的原始值</em>来代表每一个方位的名字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span>: <span class="title">String</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> north, south, east, west</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>CompassPoint.south</code>有一个隐式原始值 “south” ，以此类推。</p>
<p>你可以用 <code>rawValue</code>属性来访问一个枚举成员的<em>原始值</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> earthsOrder = <span class="type">Planet</span>.<span class="type">Earth</span>.rawValue</div><div class="line"><span class="comment">// earthsOrder is 3</span></div><div class="line"> </div><div class="line"><span class="keyword">let</span> sunsetDirection = <span class="type">CompassPoint</span>.west.rawValue</div><div class="line"><span class="comment">// sunsetDirection is "west"</span></div></pre></td></tr></table></figure>
<h4 id="从原始值初始化"><a href="#从原始值初始化" class="headerlink" title="从原始值初始化"></a>从原始值初始化</h4><p>如果你用原始值类型来定义一个枚举，那么枚举就会自动收到一个可以接受原始值类型的值的初始化器（叫做 <code>rawValue</code>的形式参数）然后返回一个<strong>枚举成员</strong>或者 <code>nil</code> 。你可以使用这个初始化器来尝试创建一个枚举的新实例。</p>
<p>这个例子从它的原始值 <code>7</code>来辨认出 <code>Uranus</code> ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> possiblePlanet = <span class="type">Planet</span>(rawValue: <span class="number">7</span>)</div><div class="line"><span class="comment">// possiblePlanet is of type Planet? and equals Planet.Uranus</span></div></pre></td></tr></table></figure>
<p>总之，不是所有可能的 <code>Int</code>值都会对应一个行星。因此原始值的初始化器总是返回可选的枚举成员。在上面的例子中， <code>possiblePlanet</code>的类型是 <code>Planet?</code> ，或者“可选项 <code>Planet</code>”</p>
<p>如果你尝试寻找有位置 <code>11</code>的行星，那么被原始值初始化器返回的可选项 <code>Planet</code>值将会是 <code>nil</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> positionToFind = <span class="number">11</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> somePlanet = <span class="type">Planet1</span>(rawValue: positionToFind) &#123;</div><div class="line">    <span class="keyword">switch</span> somePlanet &#123;</div><div class="line">    <span class="keyword">case</span> .earth:</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Mostly harmless"</span>)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Not a safe place for humans"</span>)</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"There isn`t a planet at position <span class="subst">\(positionToFind)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Prints "There isn`t a planet at position 11"</span></div></pre></td></tr></table></figure>
<h3 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h3><p>枚举在对序号考虑固定数量可能性的数据建模时表现良好，比如用来做简单整数运算的运算符。这些运算符允许你组合简单的整数数学运算表达式比如<code>5</code>到更复杂的比如<code>5+4</code>.</p>
<p>数学表达式的一大特征就是它们可以<strong>内嵌</strong>。比如说表达式<code>(5 + 4) * 2</code> 在乘法右手侧有一个数但其他表达式在乘法的左手侧。因为数据被内嵌了，用来储存数据的枚举同样需要支持内嵌——这意味着枚举需要被递归。</p>
<p><strong>递归枚举</strong>是拥有另一个枚举作为枚举成员关联值的枚举。当编译器操作递归枚举时必须插入<em>间接寻址层</em>。你可以在声明枚举成员之前使用 <code>indirect</code>关键字来明确它是<strong>递归</strong>的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpresstion</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</div><div class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> addition(<span class="type">ArithmeticExpresstion</span>, <span class="type">ArithmeticExpresstion</span>)</div><div class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpresstion</span>, <span class="type">ArithmeticExpresstion</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你同样可以在枚举之前写 <code>indirect</code> 来让整个枚举成员在需要时可以递归：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpresstion</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</div><div class="line">    <span class="keyword">case</span> addition(<span class="type">ArithmeticExpresstion</span>, <span class="type">ArithmeticExpresstion</span>)</div><div class="line">    <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpresstion</span>, <span class="type">ArithmeticExpresstion</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个枚举可以储存三种数学运算表达式：<em>单一的数字</em>，<em>两个两个表达式的加法</em>，<em>以及两个表达式的乘法</em>。 <code>addition</code> 和 <code>multiplication</code> 成员拥有同样是<strong>数学表达式的关联值—</strong>—这些关联值让嵌套表达式成为可能。比如说，表达式<code>(5 + 4) * 2</code> 乘号右侧有一个<strong>数字</strong>左侧有<strong>其他表达式</strong>。由于数据是内嵌的，用来储存数据的枚举同样需要支持内嵌——这就是说枚举需要<strong>递归</strong>。下边的代码展示了为 <code>(5 + 4) * 2</code>创建的递归枚举 <code>ArithmeticExpression</code> ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> five = <span class="type">ArithmeticExpresstion</span>.number(<span class="number">5</span>)</div><div class="line"><span class="keyword">let</span> four = <span class="type">ArithmeticExpresstion</span>.number(<span class="number">4</span>)</div><div class="line"><span class="keyword">let</span> sum  = <span class="type">ArithmeticExpresstion</span>.addition(five, four)</div><div class="line"><span class="keyword">let</span> product = <span class="type">ArithmeticExpresstion</span>.multiplication(sum, <span class="type">ArithmeticExpresstion</span>.number(<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>递归函数是一种操作<em>递归结构</em>数据的简单方法。比如说，这里有一个判断数学表达式的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(<span class="number">_</span> expression: ArithmeticExpresstion)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">switch</span> expression &#123;</div><div class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .number(value):</div><div class="line">        <span class="keyword">return</span> value</div><div class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .addition(<span class="keyword">left</span>, <span class="keyword">right</span>):</div><div class="line">        <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) + evaluate(<span class="keyword">right</span>)</div><div class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .multiplication(<span class="keyword">left</span>, <span class="keyword">right</span>):</div><div class="line">        <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) * evaluate(<span class="keyword">right</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(evaluate(product))</div><div class="line"><span class="comment">// Prints "18"</span></div></pre></td></tr></table></figure>
<p>这个函数通过直接返回<strong>关联值来判断普通数字</strong>。它通过衡量表达式<strong>左手侧和右手侧</strong>判断是<strong>加法还是乘法</strong>，然后对它们加或者乘。</p>
<blockquote>
<p>摘自：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" target="_blank" rel="external">swift 官网</a><br>所有代码在Xcode9 Swift4 环境编译没问题，代码<a href="https://github.com/keshiim/LearnSwift4" target="_blank" rel="external">戳这里 https://github.com/keshiim/LearnSwift4</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keshiim.github.io/2017/11/10/closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng keshiim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Farmer, keshiim 播种太阳🌞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/10/closure/" itemprop="url">Swift：闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-10T15:51:44+08:00">
                2017-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/10/closure/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/10/closure/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/11/10/closure/" class="leancloud_visitors" data-flag-title="Swift：闭包">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="What-is-closure"><a href="#What-is-closure" class="headerlink" title="What is closure?"></a>What is closure?</h3><p><em>闭包</em>是可以在你的代码中被传递和引用的<em>功能性独立</em>模块。Swift 中的闭包和 C  以及 Objective-C 中的 <code>blocks</code> 很像，还有其他语言中的匿名函数也类似。</p>
<p>闭包能够捕获和存储定义在其上下文中的任何常量和变量的引用，这也就是所谓的<em>闭合并包裹</em>那些常量和变量，因此被称为“闭包”，Swift 能够为你处理所有关于捕获的内存管理的操作。</p>
<p>在函数章节中有介绍的全局和内嵌函数，实际上是<em>特殊的闭包</em>。闭包符合如下<em>三种形式</em>中的一种：</p>
<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包；</li>
<li>内嵌函数是一个有名字且能从其上层函数捕获值的闭包；</li>
<li>闭包表达式是一个轻量级语法所写的可以捕获其上下文中常量或变量值的没有名字的闭包。</li>
</ul>
<p>Swift 的闭包表达式拥有简洁的风格，鼓励在常见场景中实现简洁，无累赘的语法。常见的优化包括：</p>
<ul>
<li>利用上下文推断形式参数和返回值的类型；</li>
<li>单表达式的闭包可以隐式返回；</li>
<li>简写实际参数名；</li>
<li>尾随闭包语法。</li>
</ul>
<h3 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h3><p>闭包表达式是一种在简短行内就能写完闭包的语法。闭包表达式为了缩减书写长度又不失易读明晰而提供了一系列的语法优化。下边的闭包表达式栗子通过使用几次迭代展示 <code>sorted(by:)</code>方法的精简来展示这些优化，每一次都让相同的功能性更加简明扼要。</p>
<h4 id="Sorted-方法"><a href="#Sorted-方法" class="headerlink" title="Sorted 方法"></a>Sorted 方法</h4><p>Swift 的标准库提供了一个叫做 <code>sorted(by:)</code> 的方法，会根据你提供的排序闭包将已知类型的数组的值进行排序。一旦它排序完成， <code>sorted(by:)</code> 方法会返回与原数组类型大小完全相同的一个新数组，该数组的元素是已排序好的。原始数组不会被<code>sorted(by:)</code> 方法修改。</p>
<p>这是将被排序的初始数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> names = [<span class="string">"Chris"</span>,<span class="string">"Alex"</span>,<span class="string">"Ewa"</span>,<span class="string">"Barry"</span>,<span class="string">"Daniella"</span>]</div></pre></td></tr></table></figure>
<p><code>sorted(by:)</code> 方法接收一个接收两个与数组内容相同类型的实际参数的闭包，然后返回一个 <code>Bool</code> 值来说明第一个值在排序后应该出现在第二个值的前边还是后边。如果第一个值应该出现在第二个值之前，排序闭包需要返回 <code>true</code> ，否则返回 <code>false</code><br>这个栗子对一个 <code>String</code> 类型的数组进行排序，因此排序闭包需为一个 <code>(String, String) -&gt; Bool</code> 的类型函数。</p>
<p>提供符合其类型需求的普通函数，并将它作为 <code>sorted(by:)</code>方法的形式参数传入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">backward</span><span class="params">(<span class="number">_</span> s1: String, <span class="number">_</span> s2: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> s1 &gt; s2</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> reversedNames = names.sorted(by: backward)</div><div class="line"><span class="comment">// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span></div></pre></td></tr></table></figure>
<p>如果第一个字符串 <code>s1</code> 大于第二个字符串 <code>s2</code>， <code>backwards(_:,_:)</code>函数将返回 <code>true</code>，这意味着 <code>s1</code> 应该在排序数组中排在 <code>s2</code>  的前面。以此类推，实现倒叙排列。</p>
<p>总之，这样来写本质上只是一个单一表达函数<code>( a &gt; b )</code>是非常啰嗦的。在这个栗子中，我们更倾向于使用闭包表达式在行内写一个简单的闭包。</p>
<h4 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h4><p>闭包表达式语法有如下的一般形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; (parameters) -&gt; (<span class="keyword">return</span> type) <span class="keyword">in</span></div><div class="line">   statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>闭包表达式语法能够使用<em>常量形式参数、变量形式参数</em>和<em>输入输出形式</em>参数，但<em>不能</em>提供默认值。<em>可变形式参数</em>也能使用，但需要在形式参数列表的<em>最后面使用</em>。<em>元组</em>也可被用来作为形式参数和返回类型。</p>
<p>下面这个栗子展示一个之前<code>backward(_:_:)</code>函数的闭包表达版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> s1 &gt; s2</div><div class="line">&#125;)</div><div class="line"><span class="built_in">print</span>(reversedNames)</div><div class="line"><span class="comment">// prints ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span></div></pre></td></tr></table></figure>
<p><strong>需要注意的</strong>是<em>行内闭包的形式</em>参数类型和返回类型的声明与 <code>backwards(_:_:)</code> 函数的声明相同。在这两个方式中，都书写成 <code>(s1: String, s2: String) -&gt; Bool</code>。总之对于行内闭包表达式来说，形式参数类型和返回类型都应写在<em>花括号内</em>而不是<em>花括号外面</em>。</p>
<p>闭包的<strong>函数整体部分</strong>由关键字 <code>in</code> 导入，这个关键字表示闭包的<em>形式参数类型和返回类型</em>定义已经完成，并且闭包的函数体即将开始。</p>
<p>闭包的函数体特别短以至于能够只用一行来书写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>
<h4 id="从语境中推断类型"><a href="#从语境中推断类型" class="headerlink" title="从语境中推断类型"></a>从语境中推断类型</h4><p>因排序闭包为实际参数来传递给函数，故 Swift 能推断它的形式参数类型和返回类型。 <code>sorted(by:)</code> 方法期望它的第二个形式参数是一个 <code>(String, String) -&gt; Bool</code> 类型的函数。这意味着<code>(String, String)</code>和 <code>Bool</code> 类型不需要被写成闭包表达式定义中的一部分，因为所有的类型都能被推断，返回箭头 <code>(-&gt;)</code> 和围绕在形式参数名周围的括号也能被省略：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125;)</div></pre></td></tr></table></figure>
<p>当把闭包作为行内闭包表达式传递给函数，形式参数类型和返回类型都可以被<em>推断出来</em>。所以说，当闭包被用作函数的实际参数时你都不需要用完整格式来书<em>写行内闭包</em>。</p>
<p>然而，如果你希望的话仍然可以明确类型，并且在读者阅读你的代码时如果它能避免可能存在的歧义的话还是值得的。在这个 <code>sorted(by:)</code> 方法的栗子中，闭包的目的很明确，即排序被替换。对读者来说可以放心的假设闭包可能会使用 <code>String</code> 值，因为它正帮一个字符串数组进行排序。</p>
<h4 id="从单表达式闭包隐式返回"><a href="#从单表达式闭包隐式返回" class="headerlink" title="从单表达式闭包隐式返回"></a>从单表达式闭包隐式返回</h4><p>单表达式闭包能够通过从它们的声明中删掉 <code>return</code> 关键字来隐式返回它们单个表达式的结果，前面的栗子可以写作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>
<p>这里， <code>sorted(by:)</code> 方法的第二个实际参数的函数类型已经明确必须通过闭包返回一个 <code>Bool</code> 值。因为闭包的结构包涵返回 <code>Bool</code> 值的单一表达式 <code>(s1 &gt; s2)</code>，因此没有歧义，并且 <code>return</code> 关键字能够被省略。</p>
<h4 id="简写的实际参数名"><a href="#简写的实际参数名" class="headerlink" title="简写的实际参数名"></a>简写的实际参数名</h4><p>Swift 自动对行内闭包提供<strong>简写实际参数名</strong>，你也可以通过 <code>$0 , $1 , $2</code> 等名字来引用闭包的实际参数值。</p>
<p>如果你在闭包表达式中使用这些简写实际参数名，那么你可以在闭包的实际参数列表中忽略对其的定义，并且简写实际参数名的数字和类型将会从期望的函数类型中推断出来。 <code>in</code>  关键字也能被省略，因为闭包表达式完全由它的函数体组成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125; )</div></pre></td></tr></table></figure>
<h4 id="运算符函数"><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h4><p>实际上还有一种更简短的方式来撰写上述闭包表达式。Swift 的 <code>String</code> 类型定义了关于大于号<code>（ &gt;）</code>的特定字符串实现，让其作为一个有两个 <code>String</code> 类型形式参数的函数并返回一个 <code>Bool</code> 类型的值。这正好与 <code>sorted(by:)</code> 方法的第二个形式参数需要的函数相匹配。因此，你能简单地传递一个大于号，并且 Swift 将推断你想使用大于号特殊字符串函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &gt;)</div></pre></td></tr></table></figure>
<h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><p>如果你需要将一个很长的闭包表达式作为函数<code>最后一个实际参数</code>传递给函数，使用尾随闭包将增强函数的可读性。尾随闭包是一个被书写在函数形式参数的<em>括号外面</em>（后面）的闭包表达式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionThatTakesAClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    <span class="comment">//function body goes here</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//here`s how you call this function without using a trailing closure</span></div><div class="line">someFunctionThatTakesAClosure(closure: &#123;</div><div class="line">    <span class="comment">//closure`s body goes here</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">//here`s how you call this function with a trailing closure instead</span></div><div class="line">someFunctionThatTakesAClosure &#123;</div><div class="line">    <span class="comment">//trailing closure`s body goes here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>字符串排列闭包也可以作为一个尾随闭包被书写在 <code>sorted(by:)</code> 方法的括号外面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted() &#123;$<span class="number">0</span> &gt; $<span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<p>如果闭包表达式作为函数的唯一实际参数传入，而你又使用了尾随闭包的语法，那你就不需要在函数名后边写圆括号了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted &#123;$<span class="number">0</span> &gt; $<span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<p>当闭包很长以至于不能被写成一行时尾随闭包就显得非常有用了。举个栗子，Swift 的 <code>Array</code> 类型中有一个以闭包表达式为唯一的实际参数的 <code>map(_:)</code> 方法。数组中每一个元素调用一次该闭包，并且返回该元素所映射的值（有可能是其他类型）。具体的映射方式和返回值的类型有闭包来指定。</p>
<p>在给数组中每一个成员提供闭包时， <code>map(_:)</code>方法返回一个新的数组，<em>数组中包涵与原数组一一对应的映射值</em>。</p>
<p>使用一个带有尾随闭包的 <code>map(_:)</code> 方法将一个包含 <code>Int</code> 值的数组转换成一个包含 <code>String</code> 值的数组。这个数组 <code>[16,58,510]</code>被转换成一个新的数组 <code>[&quot;OneSix&quot;,&quot;FiveEight&quot;,&quot;FiveOneZero&quot;]</code> ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> digitNames = [<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"One"</span>, <span class="number">2</span>: <span class="string">"Two"</span>,  <span class="number">3</span>: <span class="string">"Three"</span>, <span class="number">4</span>: <span class="string">"Four"</span>,</div><div class="line">                  <span class="number">5</span>: <span class="string">"Five"</span>, <span class="number">6</span>: <span class="string">"Six"</span>, <span class="number">7</span>: <span class="string">"Seven"</span>, <span class="number">8</span>: <span class="string">"Eight"</span>, <span class="number">9</span>: <span class="string">"Nine"</span>]</div><div class="line"><span class="keyword">let</span> numbers = [<span class="number">16</span>, <span class="number">58</span>, <span class="number">510</span>]</div><div class="line"><span class="keyword">let</span> strings = numbers.<span class="built_in">map</span> &#123; (number) -&gt; <span class="type">String</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">var</span> number = number</div><div class="line">    <span class="keyword">var</span> output = <span class="string">""</span></div><div class="line">    <span class="keyword">repeat</span> &#123;</div><div class="line">        output = digitNames[number % <span class="number">10</span>]! + output</div><div class="line">        number /= <span class="number">10</span></div><div class="line">    &#125; <span class="keyword">while</span> number &gt; <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> output</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(strings)</div><div class="line"><span class="comment">// prints ["OneSix", "FiveEight", "FiveOnezero"]</span></div></pre></td></tr></table></figure>
<p><code>map(_:)</code> 方法在数组中为每一个元素调用了一次闭包表达式。你不需要指定闭包的输入形式参数 number 的类型，因为它能从数组中将被映射的值来做推断。</p>
<h3 id="捕获值"><a href="#捕获值" class="headerlink" title="捕获值"></a>捕获值</h3><p>一个闭包能够从上下文<em>捕获</em>已被定义的<em>常量和变量</em>。即使定义这些常量和变量的<strong>原作用域已经不存在</strong>，闭包仍能够在其函数体内<em>引用和修</em>改这些值。</p>
<p>在 Swift 中，一个能够捕获值的闭包最简单的模型是<em>内嵌函数</em>，即被书写在另一个函数的内部。一个内嵌函数能够捕获外部函数的实际参数并且能够捕获任何在外部函数的内部定义了的常量与变量。</p>
<p>这里有个命名为 <code>makeIncrement</code> 的函数栗子，其中包含了一个名叫 <code>incrementer</code> 一个内嵌函数。这个内嵌 <code>incrementer()</code>  函数能在它的上下文捕获两个值， <code>runningTotal</code>  和 <code>amount</code> 。在捕获这些值后，通过 <code>makeIncrement</code> 将 <code>incrementer</code>作为一个闭包返回，每一次调用 <code>incrementer</code> 时，将以 <code>amount</code>作为增量来增加 <code>runningTotal</code> ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementer</span><span class="params">(forIncrement amount: Int)</span></span> -&gt; () -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">var</span> runningTotal = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementer</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        runningTotal += amount</div><div class="line">        <span class="keyword">return</span> runningTotal</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> incrementer</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> incrementByTwo = makeIncrementer(forIncrement: <span class="number">2</span>)</div><div class="line"><span class="built_in">print</span>(incrementByTwo())</div><div class="line"><span class="built_in">print</span>(incrementByTwo())</div><div class="line"><span class="built_in">print</span>(incrementByTwo())</div><div class="line"><span class="comment">//prints 2</span></div><div class="line"><span class="comment">//       4</span></div><div class="line"><span class="comment">//       6</span></div></pre></td></tr></table></figure>
<p><code>incrementer()</code> 函数是没有任何形式参数， <code>runningTotal</code> 和 <code>amount</code> 不是来自于函数体的内部，而是通过捕获主函数的 <code>runningTotal</code> 和 <code>amount</code> <strong>把它们内嵌在自身函数内部供使用</strong>。当调用 <code>makeIncrementer</code>  结束时通过引用<em>捕获来确保不会消失</em>，并确保了在下次再次调用 <code>incrementer</code> 时， <code>runningTotal</code> 将继续增加。</p>
<p>如果你建立了第二个 <code>incrementer</code> ,它将会有一个新的、独立的 <code>runningTotal</code> 变量的引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> incrementBySeven = makeIncrementer(forIncrement: <span class="number">7</span>)</div><div class="line"><span class="built_in">print</span>(incrementBySeven())</div><div class="line"><span class="comment">//prints 7</span></div></pre></td></tr></table></figure>
<p>再次调用原来增量器 ( <code>incrementByTwo</code> )  继续增加它自己的变量 <code>runningTotal</code> 的值，并且不会影响 <code>incrementBySeven</code> 捕获的变量 <code>runningTotal</code> 值（<code>8</code>）。</p>
<h3 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h3><p>在上面例子中， <code>incrementBySeven</code> 和 <code>incrementByTwo</code> 是常量，但是这些常量指向的闭包仍可以增加已捕获的变量 <code>runningTotal</code> 的值。这是因为<em>函数</em>和<em>闭包</em>都是<strong>引用类型</strong>。</p>
<p>无论你什么时候安赋值一个函数或者闭包给常量或者变量，你实际上都是将常量和变量设置为对函数和闭包的引用。这上面这个例子中，闭包选择 incrementByTwo 指向一个常量，而不是闭包它自身的内容。<br>这也意味着你赋值一个闭包到两个不同的常量或变量中，这两个常量或变量都将指向相同的闭包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> alsoIncrementByTwo = incrementByTwo</div><div class="line"><span class="built_in">print</span>(alsoIncrementByTwo())</div><div class="line"><span class="comment">//prints 10</span></div></pre></td></tr></table></figure>
<h3 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h3><p>当闭包作为一个实际参数传递给一个函数的时候，我们就说这个闭包<em>逃逸</em>了，<strong>因为它可以在函数返回之后被调用</strong>。当你声明一个接受闭包作为形式参数的函数时，你可以在形式参数前写 <code>@escaping</code> 来明确闭包是允许逃逸的。</p>
<p>闭包可以逃逸的一种方法是<strong>被储存在定义于函数外的变量里</strong>。比如说，很多函数接收闭包实际参数来作为启动异步任务的回调。函数在启动任务后返回，但是闭包要直到任务完成——<em>闭包需要逃逸</em>，以便于稍后调用。举例来说：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = []</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHanlder: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    completionHandlers.append(completionHanlder)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数 <code>someFunctionWithEscapingClosure(_:)</code> 接收一个闭包作为实际参数并且添加它到声明在函数<em>外部的数组里</em>。如果你不标记函数的形式参数为 <code>@escaping</code> ，你就会遇到编译时错误。</p>
<p>让闭包 <code>@escaping</code> 意味着你必须在闭包中显式地引用 <code>self</code> ，比如说，下面的代码中，传给 <code>someFunctionWithEscapingClosure(_:)</code>的闭包是一个逃逸闭包，也就是说它需要显式地引用 <code>self</code> 。相反，传给 <code>someFunctionWithNonescapingClosure(_:)</code> 的闭包是非逃逸闭包，也就是说它可以隐式地引用 <code>self</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHanlder: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    completionHandlers.append(completionHanlder)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithNonescapingClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    closure()</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">11</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</div><div class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x = <span class="number">100</span> &#125;</div><div class="line">        someFunctionWithNonescapingClosure &#123; x = <span class="number">200</span> &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> instance = <span class="type">SomeClass</span>()</div><div class="line">instance.doSomething()</div><div class="line"><span class="built_in">print</span>(instance.x)</div><div class="line"><span class="comment">// Prints "200"</span></div><div class="line">completionHandlers.first?()</div><div class="line"><span class="built_in">print</span>(instance.x)</div><div class="line"><span class="comment">// Prints "100"</span></div></pre></td></tr></table></figure>
<h3 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h3><p><em>自动闭包</em>是一种<strong>自动创建的用来把作为实际参数传递给函数的表达式打包的闭包</strong>。<strong>它不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值</strong>。这个语法的好处在于<em>通过写普通表达式代替显式闭包而使你省略包围函数形式参数的括号。</em></p>
<p><em>调用</em>一个带有自动闭包的函数是很常见的，但实现这类函数就不那么常见了。比如说， <code>assert(condition:message:file:line:)</code> 函数为它的 <code>condition</code>  和 <code>message</code> 形式参数接收一个<strong>自动闭包</strong>；它的 <code>condition</code> 形式参数只有在调试构建是才评判，而且 <code>message</code> 形式参数只有在 <code>condition</code> 是 <code>false</code> 时才评判。</p>
<p>自动闭包允许你<strong>延迟处理</strong>，因此闭包内部的代码直到你调用它的时候才会运行。对于有副作用或者占用资源的代码来说很有用，因为它可以允许你控制代码何时才进行求值。下面的代码展示了<em>闭包如何延迟求值</em>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> customersInLine = [<span class="string">"Chris"</span>, <span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</div><div class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</div><div class="line"><span class="comment">// Prints "5"</span></div><div class="line"> </div><div class="line"><span class="keyword">let</span> customerProvider = &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</div><div class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</div><div class="line"><span class="comment">// Prints "5"</span></div><div class="line"> </div><div class="line"><span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</div><div class="line"><span class="comment">// Prints "Now serving Chris!"</span></div><div class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</div><div class="line"><span class="comment">// Prints "4"</span></div></pre></td></tr></table></figure>
<p>尽管 <code>customersInLine</code> 数组的第一个元素以闭包的一部分被移除了，但任务并没有执行直到闭包被实际调用。如果闭包永远不被调用，那么闭包里边的表达式就永远不会求值。注意 <code>customerProvider</code> 的类型不是 <code>String</code> 而是  <code>() -&gt; String</code> ——一个不接受实际参数并且返回一个字符串的函数。</p>
<p>当你传一个闭包作为实际参数到函数的时候，你会得到与延迟处理相同的行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(customer customerProvider: <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</div><div class="line">&#125;</div><div class="line">serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; )</div><div class="line"><span class="comment">// Prints "Now serving Alex!"</span></div></pre></td></tr></table></figure>
<p>上边的函数 <code>serve(customer:)</code> 接收一个<strong>明确的</strong>返回下一个<strong>客户名称的闭包</strong>。下边的另一个版本的 <code>serve(customer:)</code> 执行相同的任务但是<em>不使用明确的闭包</em>而是通过 <code>@autoclosure</code> 标志标记它的形式参数<strong>使用了自动闭包</strong>。现在你可以调用函数就像它接收了一个 <code>String</code> 实<code>际参数</code>而不是<code>闭包</code>。实际参数自动地转换为闭包，因为 <code>customerProvider</code> 形式参数的类型被标记为 <code>@autoclosure</code> 标记。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// customersInLine is ["Ewa", "Barry", "Daniella"]</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(customer customerProvider: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</div><div class="line">&#125;</div><div class="line">serve(customer: customersInLine.remove(at: <span class="number">0</span>))</div><div class="line"><span class="comment">// Prints "Now serving Ewa!"</span></div></pre></td></tr></table></figure>
<p>如果你想要自动闭包允许逃逸，就同时使用 <code>@autoclosure</code> 和 <code>@escaping</code> 标志。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// customersInLine is ["Barry", "Daniella"]</span></div><div class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] = []</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectCustomerProviders</span><span class="params">(<span class="number">_</span> customerProvider: @autoclosure @escaping <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</div><div class="line">    customerProviders.append(customerProvider)</div><div class="line">&#125;</div><div class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>)) <span class="comment">//体现自动闭包的特性</span></div><div class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</div><div class="line"> </div><div class="line"><span class="built_in">print</span>(<span class="string">"Collected <span class="subst">\(customerProviders.<span class="built_in">count</span>)</span> closures."</span>)</div><div class="line"><span class="comment">// Prints "Collected 2 closures."</span></div><div class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Prints "Now serving Barry!"</span></div><div class="line"><span class="comment">// Prints "Now serving Daniella!"</span></div><div class="line"><span class="comment">// customersInLine is []空了</span></div></pre></td></tr></table></figure>
<p>上边的代码中，不是调用传入后作为 <code>customerProvider</code> 实际参数的闭包， <code>collectCustomerProviders(_:)</code> 函数把闭包追加到了 <code>customerProviders</code> 数组的末尾。数组声明在函数的生效范围之外，<strong>也就是说数组里的闭包有可能在函数返回之后执行</strong>(<em>体现逃逸闭包特性</em>)。结果， <code>customerProvider</code> 实际参数的值必须能够逃逸出函数的生效范围。</p>
<blockquote>
<p>摘自：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" target="_blank" rel="external">swift 官网</a><br>所有代码在Xcode9 Swift4 环境编译没问题，代码<a href="https://github.com/keshiim/LearnSwift4" target="_blank" rel="external">戳这里 https://github.com/keshiim/LearnSwift4</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keshiim.github.io/2017/11/10/Swift-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng keshiim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Farmer, keshiim 播种太阳🌞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/10/Swift-function/" itemprop="url">Swift：函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-10T13:24:20+08:00">
                2017-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/10/Swift-function/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/10/Swift-function/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/11/10/Swift-function/" class="leancloud_visitors" data-flag-title="Swift：函数">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>函数</strong>是一个独立的代码块，用来执行特定的任务。通过给函数一个名字来定义它的功能，并且在需要的时候，通过这个名字来“调用”函数执行它的任务。</p>
<p>Swift 统一的函数语法十分灵活，可以表达从简单的无形式参数的 C 风格函数到复杂的每一个形式参数都带有局部和外部形式参数名的 Objective-C 风格方法的任何内容。</p>
<ul>
<li>形式参数能提供一个<em>默认的值</em>来简化函数的调用</li>
<li>也可以被当作<em>输入输出形式参数被传递</em></li>
<li>它在函数执行完成时修改传递来的变量。</li>
</ul>
<p>Swift中函数也是一等公民，每个函数都有类型，由函数的形式参数类型和返回类型组成。可做用作其他函数的<em>参数</em>或<em>返回值</em>，同时也可以写在其他函数内部来在<em>内嵌范围封装有用的功能</em>。</p>
<h3 id="定义和调用函数"><a href="#定义和调用函数" class="headerlink" title="定义和调用函数"></a>定义和调用函数</h3><p>当你定义了一个函数的时候，你可以选择定义一个或者多个命名的分类的值作为<em>函数的输入</em>（<em>所谓的形式参数</em>），并且/或者定义函数完成后将要传回作为<em>输出的值的类型</em>（<em>所谓它的返回类型</em>）。</p>
<p>每一个函数都有一个<em>函数名</em>，它描述函数执行的任务。要使用一个函数，你可以通过“调用”函数的名字并且传入一个符合<em>函数形式参数类型</em>的输入值（<em>所谓实际参数</em>）来调用这个函数。——给函数提供的实际参数的顺序必须符合函数的<em>形式参数列表顺序</em>。</p>
<p>下边栗子🌰中的函数叫做 <code>greet(person:)</code> ，跟它的功能一致——它接收一个人的名字作为输入然后返回对这个人的问候。要完成它，你需要定义一个输入形式参数——一个叫做 person 的 <code>String</code>类型值——并且返回一个 <code>String</code> 类型，它将会包含对这个人的问候：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">let</span> greeting = <span class="string">"Hello, "</span> + person + <span class="string">"!"</span></div><div class="line">    <span class="keyword">return</span> greeting</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(greet(person: <span class="string">"zheng"</span>))</div></pre></td></tr></table></figure>
<p>这些信息都被包含在了函数的定义中，它使用一个 <code>func</code>的关键字前缀。你可以用一个返回箭头 <code>-&gt;</code> (一个连字符后面跟一个向右的尖括号)来明确函数<em>返回的类型</em>。<br>你可以通过在 <code>person</code> 标签后边给函数 <code>greet(person:)</code>传入一个用圆括号包裹的 <code>String</code>实际参数值来调用它，例如 <code>greet(person: &quot;Anna&quot;)</code>。</p>
<p>为了简化这个函数的主体，我们将创建信息和返回语句组合到一行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">greetAgain</span><span class="params">(person: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello again, "</span> + person + <span class="string">"!"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(greetAgain(person: <span class="string">"Anna"</span>))</div><div class="line"><span class="comment">// Prints "Hello again, Anna!"</span></div></pre></td></tr></table></figure>
<h3 id="函数的形式参数和返回值"><a href="#函数的形式参数和返回值" class="headerlink" title="函数的形式参数和返回值"></a>函数的形式参数和返回值</h3><p>在 Swift 中，函数的形式参数和返回值非常灵活。你可以定义从一个简单的只有一个未命名形式参数的工具函数到那种具有形象的参数名称和不同的形式参数选项的复杂函数之间的任何函数。</p>
<h4 id="无形式参数的函数"><a href="#无形式参数的函数" class="headerlink" title="无形式参数的函数"></a>无形式参数的函数</h4><p>函数没有要求必须输入一个参数，这里有一个没有输入形式参数的函数，无论何时它被调用永远会返回相同的 <code>String</code>信息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHelloWorld</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello, world"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(sayHelloWorld())</div></pre></td></tr></table></figure>
<p>函数的定义仍然需要在名字后边加一<em>个圆括号</em>，即使它不接受形式参数也得这样做。当函数被调用的时候也要在函数的名字后边<em>加一个空的圆括号</em>。</p>
<h4 id="多形式参数的函数"><a href="#多形式参数的函数" class="headerlink" title="多形式参数的函数"></a>多形式参数的函数</h4><p>函数可以输入多个形式参数，可以写在函数后边的圆括号内，用<strong>逗号分隔</strong>。</p>
<p>这个函数以一个人的名字以及是否被问候过为输入，并返回对这个人的相应的问候：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">greetAgain</span><span class="params">(person: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello again, <span class="subst">\(person)</span>!"</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: String, alreadyGreeted: Bool)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">if</span> alreadyGreeted &#123;</div><div class="line">        <span class="keyword">return</span> greetAgain(person: person)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> greet(person: person)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(greet(person: <span class="string">"Tim"</span>, alreadyGreeted: <span class="literal">true</span>))</div><div class="line"><span class="comment">// Prints "Hello again, Tim!"</span></div></pre></td></tr></table></figure>
<p>通过在圆括号中传入带有 <code>person</code> 标签的 <code>String</code>实际参数值和带有 <code>alreadyGreeted</code> 标签的 <code>Bool</code>实际参数值来调用 <code>greet(person:alreadyGreeted:)</code>这个函数，实际参数之间用<em>逗号分隔</em>。注意这个函数与之前展示的函数<code>greet(person:)</code>是明显不同的。尽管两个函数都叫做 greet ， <code>greet(person:alreadyGreeted:)</code> 接收两个实际参数但 <code>greet(person:)</code>函数只接收一个。</p>
<h4 id="无返回值的函数"><a href="#无返回值的函数" class="headerlink" title="无返回值的函数"></a>无返回值的函数</h4><p>函数定义中没有要求必须有一个返回类型。下面是另一个版本的 <code>greet(person:)</code>函数，它将自己的 <code>String</code>值打印了出来而不是返回它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: String)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Hello, <span class="subst">\(person)</span>!"</span>)</div><div class="line">&#125;</div><div class="line">greet(person: <span class="string">"Dave"</span>)</div></pre></td></tr></table></figure>
<p>正因为它不需要返回值，函数在定义的时候就没有包含返回箭头<code>（-&gt;）</code>或者返回类型。</p>
<blockquote>
<p>注意：严格来讲，函数 <code>greet(person:)</code>还是有一个返回值的，尽管没有定义返回值。没有定义返回类型的函数实际上会返回一个特殊的类型 <code>Void</code>。它其实是一个空的元组，作用相当于没有元素的元组，可以写作 <code>()</code></p>
</blockquote>
<p>当函数被调用时，函数的返回值可以被忽略：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="number">_</span> = printAndCount(string: string)</div></pre></td></tr></table></figure>
<h4 id="多返回值的函数"><a href="#多返回值的函数" class="headerlink" title="多返回值的函数"></a>多返回值的函数</h4><p>为了让函数返回多个值作为一个复合的返回值，你可以使用元组类型作为返回类型。</p>
<p>下面的栗子定义了一个叫做<code>minMax(array:)</code>的函数，它可以找到类型为 <code>Int</code>的数组中最大数字和最小数字。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>) &#123;</div><div class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</div><div class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</div><div class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</div><div class="line">            currentMin = value</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</div><div class="line">            currentMax = value</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (currentMin, currentMax)</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(minMax(array: [<span class="number">1</span>, <span class="number">2</span>, -<span class="number">4</span>, <span class="number">3</span>, <span class="number">74</span>]))</div><div class="line"><span class="comment">// prints (min: -4, max: 74)</span></div></pre></td></tr></table></figure>
<p>函数 <code>minMax(array:)</code>返回了一个包含两个 <code>Int</code>值的元组。这两个值被 <code>min</code>和 <code>max</code> 标记，这样当查询函数返回值的时候就可以通过名字访问了。</p>
<h4 id="可选元组返回类型"><a href="#可选元组返回类型" class="headerlink" title="可选元组返回类型"></a>可选元组返回类型</h4><p>如果元组在函数的返回类型中有可能“没有值”，你可以用一个<em>可选元组返回类型</em>来说明整个元组的可能是 <code>nil</code> 。书法是在可选元组类型的圆括号后边添加一个问号<code>（?）</code>例如 <code>(Int, Int)?</code> 或者 <code>(String, Int, Bool)?</code> 。</p>
<p>上面的函数<code>minMax(array:)</code>返回了一个包含两个 <code>Int</code>值的元组。总之，函数不会对传入的数组进行安全性检查。如果 <code>array</code>的实际参数包含了一个空的数组，上面定义的函数 <code>minMax(array:)</code>在尝试调用 <code>array[0]</code>的时候就会触发一个运行时错误。</p>
<p>为了安全的处理这种“空数组”的情景，就需要把<code>minMax(array:)</code>函数的返回类型写做<strong>可选元组</strong>，当数组是空的时候返回一个 <code>nil</code>值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax2</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>)? &#123;</div><div class="line">    <span class="keyword">guard</span> !array.isEmpty <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</div><div class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</div><div class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</div><div class="line">            currentMin = value</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</div><div class="line">            currentMax = value</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (currentMin, currentMax)</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(minMax2(array: [<span class="number">1</span>, -<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">67</span>]) ?? <span class="string">""</span>) <span class="comment">//prints (min: -3, max: 67)</span></div><div class="line"><span class="built_in">print</span>(minMax2(array: []) ?? <span class="string">""</span>)                <span class="comment">//prints ""</span></div></pre></td></tr></table></figure>
<h3 id="函数实际参数标签和形式参数名"><a href="#函数实际参数标签和形式参数名" class="headerlink" title="函数实际参数标签和形式参数名"></a>函数实际参数标签和形式参数名</h3><p>每一个函数的形式参数都包含实际参数标签和形式参数名。<em>实际参数标签用在调用函数的时候</em>；在调用函数的时候每一个实际参数前边都要写实际参数标签。<em>形式参数名用在函数的实现当中</em>。<strong>默认情况下，形式参数使用它们的形式参数名作为实际参数标签</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(firstParameterName: Int, secondParameterName: Int)</span></span> &#123;</div><div class="line">    <span class="comment">// In the function body, firstParameterName and secondParameterName</span></div><div class="line">    <span class="comment">// refer to the argument values for the first and second parameters.</span></div><div class="line">&#125;</div><div class="line">someFunction(firstParameterName: <span class="number">1</span>, secondParameterName: <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>左右的<em>形式参数</em>必须有<strong>唯一</strong>的名字。尽管有可能多个形式参数拥有相同的实际参数标签，唯一的实际参数标签有助于让你的代码更加易读。</p>
<h4 id="指定实际参数标签"><a href="#指定实际参数标签" class="headerlink" title="指定实际参数标签"></a>指定实际参数标签</h4><p>在提供形式参数名之前写实际参数标签，用空格分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(argumentLabel parameterName: Int)</span></span> &#123;</div><div class="line">    <span class="comment">// In the function body, parameterName refers to the argument value</span></div><div class="line">    <span class="comment">// for that parameter.</span></div><div class="line">&#125;</div><div class="line">someFunction(argumentLabel: xx)</div></pre></td></tr></table></figure>
<h4 id="省略实际参数标签"><a href="#省略实际参数标签" class="headerlink" title="省略实际参数标签"></a>省略实际参数标签</h4><p>如果对于函数的形式参数不想使用实际参数标签的话，可以利用下划线（ _ ）来为这个形式参数代替显式的实际参数标签。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(<span class="number">_</span> firstParameterName: Int, secondParameterName: Int)</span></span> &#123;</div><div class="line">    <span class="comment">// In the function body, firstParameterName and secondParameterName</span></div><div class="line">    <span class="comment">// refer to the argument values for the first and second parameters.</span></div><div class="line">&#125;</div><div class="line">someFunction(<span class="number">1</span>, secondParameterName: <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h4 id="默认形式参数值"><a href="#默认形式参数值" class="headerlink" title="默认形式参数值"></a>默认形式参数值</h4><p>你可以通过在形式参数类型后给形式参数赋一个值来给函数的任意形式参数定义一个<strong>默认值</strong>。如果定义了默认值，你就可以在调用函数时候<em>省略这个形式参数</em>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(parameterWithDefault: Int = <span class="number">12</span>)</span></span> &#123;</div><div class="line">    <span class="comment">// In the function body, if no arguments are passed to the function</span></div><div class="line">    <span class="comment">// call, the value of parameterWithDefault is 12.</span></div><div class="line">&#125;</div><div class="line">someFunction(parameterWithDefault: <span class="number">6</span>) <span class="comment">// parameterWithDefault is 6</span></div><div class="line">someFunction()                        <span class="comment">// parameterWithDefault is 12</span></div></pre></td></tr></table></figure>
<p>把不带有默认值的形式参数放到函数的形式参数列表中带有默认值的形式参数前边，不带有默认值的形式参数通常对函数有着重要的意义——把它们写在前边可以便于让人们看出来无论是否省略带默认值的形式参数，调用的都是同一个函数。</p>
<h4 id="可变形式参数"><a href="#可变形式参数" class="headerlink" title="可变形式参数"></a>可变形式参数</h4><p>一个可变形式参数可以接受<strong>零或者多个</strong>特定类型的值。当调用函数的时候你可以利用可变形式参数来声明形式参数可以被传入值的数量<em>是可变的</em>。可以通过在形式参数的类型名称后边插入三个点符号（ …）来书写可变形式参数。传入到可变参数中的值在函数的主体中被当作是<strong>对应类型的数组</strong>。</p>
<p>举个栗子，一个可变参数的名字是 <code>numbers</code>类型是 <code>Double...</code>在函数的主体中它会被当作名字是 <code>numbers</code> 类型是 <code>[Double]</code>的常量数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">arithmeticMean</span><span class="params">(numbers: Double...)</span></span> -&gt; <span class="type">Double</span> &#123;</div><div class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</div><div class="line">        total += number</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> total / <span class="type">Double</span>(numbers.<span class="built_in">count</span>)</div><div class="line">&#125;</div><div class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line"><span class="comment">// returns 3.0, which is the arithmetic mean of these five numbers</span></div><div class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)</div><div class="line"><span class="comment">// returns 10.0, which is the arithmetic mean of these three numbers</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：一个函数最多只能有一个可变形式参数。</p>
</blockquote>
<h4 id="输入输出形式参数"><a href="#输入输出形式参数" class="headerlink" title="输入输出形式参数"></a>输入输出形式参数</h4><p>你想函数能够修改一个形式参数的值，而且你想这些改变在函数结束之后<em>依然生效</em>，那么就需要将形式参数定义为<em>输入输出形式参数</em>。<br>在形式参数定义开始的时候在前边添加一个 <code>inout</code>关键字可以定义一个<em>输入输出形式参数</em>。输入输出形式参数有一个能输入给函数的值，函数能对其进行修改，还能输出到函数外边替换原来的值。</p>
<p>调用时，你只能把<strong>变量</strong>作为输入输出形式参数的实际参数。你不能用常量或者字面量作为实际参数，因为常量和字面量不能修改。在将变量作为实际参数传递给输入输出形式参数的时候，直接在它前边添加一个<code>(&amp;)</code><em>符号来明确可以被函数修改</em>。</p>
<p>这里有一个 <code>swapTwoInts(_:_:)</code>函数，它有两个输入输出整数形式参数 a和 b：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Int, <span class="number">_</span> b: <span class="keyword">inout</span> Int)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> temporaryA = a</div><div class="line">    a = b</div><div class="line">    b = temporaryA</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以通过两个<code>Int</code>类型的变量来调用函数 <code>swapTwoInts(_:_:)</code>去调换它们两个的值，需要注意的是 <code>someInt</code>的值和 <code>anotherInt</code>的值在传入函数 <code>swapTwoInts(_:_:)</code>时都添加了’<em>和</em>‘符号。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></div><div class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></div><div class="line"><span class="built_in">swap</span>(&amp;someInt, &amp;anotherInt)</div><div class="line"><span class="built_in">print</span>(<span class="string">"someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>"</span>)</div><div class="line"><span class="comment">// prints "someInt is now 107, and anotherInt is now 3"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>输入输出形式参数与函数的返回值不同。上边的 <code>swapTwoInts</code>没有定义返回类型和返回值，但它仍然能修改 <code>someInt</code>和 <code>anotherInt</code>的值。输入输出形式参数是函数能影响到函数范围外的另一种替代方式。</p>
</blockquote>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>每一个函数都有一个特定的<strong>函数类型</strong>，它由<em>形式参数类型，返回类型</em>组成。<br>栗子🌰：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoInts</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiplyTwoInts</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> a * b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上边的栗子定义了两个简单的数学函数 <code>addTwoInts</code>和 <code>multiplyTwoInts</code> 。这两个函数每个传入两个 <code>Int</code>值，返回一个 <code>Int</code>值，就是函数经过数学运算得出的结果。</p>
<p>这两个函数的类型都是 <code>(Int, Int) -&gt; Int</code> 。也读作：<br><em>“有两个形式参数的函数类型，它们都是 Int类型，并且返回一个 Int类型的值。”</em></p>
<p>下边的另外一个栗子，一个没有形式参数和返回值的函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"hello, world"</span>)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"hello, world"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的类型是 <code>() -&gt; Void</code>，或者 <em>“一个没有形式参数的函数，返回 <code>Void</code>。”</em></p>
<h4 id="使用函数类型"><a href="#使用函数类型" class="headerlink" title="使用函数类型"></a>使用函数类型</h4><p>你可以像使用 Swift 中的其他类型一样使用函数类型。例如，你可以给一个常量或变量定义一个函数类型，并且为变量指定一个相应的函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> = addTwoInts</div></pre></td></tr></table></figure>
<p>读作：<em>“定义一个叫做 <code>mathFunction</code>的变量，它的类型是‘一个能接受两个 <code>Int</code>值的函数，并返回一个 <code>Int</code>值。’将这个新的变量指向 <code>addTwoInts</code>函数。”</em></p>
<p>可以利用名字 <code>mathFunction</code>来调用指定的函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>)</span>)"</span>)</div><div class="line"><span class="comment">// prints "Result: 5"</span></div></pre></td></tr></table></figure>
<p>同样也适用于<code>multiplyTwoInts(_:_:)</code></p>
<h4 id="函数类型作为形式参数类型"><a href="#函数类型作为形式参数类型" class="headerlink" title="函数类型作为形式参数类型"></a>函数类型作为形式参数类型</h4><p>利用使用一个函数的类型例如 <code>(Int, Int) -&gt; Int</code>作为其他函数的<em>&gt; Int`</em>。这允许你预留函数的部分实现从而让函数的调用者在调用函数的时候提供。</p>
<p>下面的栗子打印出了上文中数学函数执行后的结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMathResult</span><span class="params">(<span class="number">_</span> mathFunction: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>, <span class="number">_</span> a: <span class="type">Int</span>, <span class="number">_</span> b: <span class="type">Int</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(a, b)</span>)"</span>)</div><div class="line">&#125;</div><div class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)</div><div class="line"><span class="comment">// Prints "Result: 8"</span></div></pre></td></tr></table></figure>
<p>函数 <code>printMathResult(_:_:_:)</code>的作用就是当调用一个相应类型的数学函数的时候打印出结果。它并不关心函数在实现过程中究竟做了些什么，它只关心函数是不是正确的类型。这使得函数 <code>printMathResult(_:_:_:)</code>以一种类型安全的方式把自身的功能传递给调用者。</p>
<h4 id="函数类型作为返回类型"><a href="#函数类型作为返回类型" class="headerlink" title="函数类型作为返回类型"></a>函数类型作为返回类型</h4><p>利用函数的类型作为另一个函数的返回类型。写法是在函数的返回箭头（ -&gt;）后立即写一个完整的<em>函数类型</em>。<br>下边的栗子定义了两个简单函数叫做 <code>stepForward(_:)</code>和 <code>stepBackward(_:)</code>。函数 <code>stepForward(_:)</code>返回一个大于输入值的值，而 <code>stepBackward(_:)</code>返回一个小于输入值的值。这两个函数的类型都是 <code>(Int) -&gt; Int</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(<span class="number">_</span> input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> input + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(<span class="number">_</span> input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> input - <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一个函数 <code>chooseStepFunction(backward:)</code>，它的返回类型是“一个函数的类型 <code>(Int) -&gt; Int</code>”。函数 <code>chooseStepFunction(backward:)</code>返回了 <code>stepForward(_:)</code>函数或者一个基于叫做 <code>backwards</code> 的布尔量形式参数的函数 <code>stepBackward(_:)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backwards: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> backwards ? stepBackward : stepForward</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> currentValue = <span class="number">3</span></div><div class="line"><span class="keyword">let</span> moveNearerToZero = chooseStepFunction(backward: currentValue &gt; <span class="number">0</span>)</div><div class="line"><span class="comment">// moveNearerToZero now refers to the stepBackward() function</span></div></pre></td></tr></table></figure>
<h3 id="内嵌函数"><a href="#内嵌函数" class="headerlink" title="内嵌函数"></a>内嵌函数</h3><p>到目前为止，你在本章中遇到的所有函数都是全局函数，都是在全局的范围内进行定义的。你也可以在函数的内部定义另外一个函数。这就是内嵌函数。</p>
<p>内嵌函数在默认情况下在外部是被隐藏起来的，但却仍然可以通过包裹它们的函数来调用它们。包裹的函数也可以返回它内部的一个内嵌函数来在另外的范围里使用。</p>
<p>你可以重写上边的栗子 <code>chooseStepFunction(backward:)</code>来使用和返回内嵌函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backward: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input + <span class="number">1</span>&#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input - <span class="number">1</span>&#125;</div><div class="line">    <span class="keyword">return</span> backward ? stepBackward : stepForward</div><div class="line">&#125;</div><div class="line">currentValue = -<span class="number">4</span></div><div class="line">moveNearerToZero = chooseStepFunction(backward: currentValue &gt; <span class="number">0</span>)</div><div class="line"><span class="keyword">while</span> currentValue != <span class="number">0</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(currentValue)</span>... "</span>)</div><div class="line">    currentValue = moveNearerToZero(currentValue)</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</div><div class="line"><span class="comment">// -4...</span></div><div class="line"><span class="comment">// -3...</span></div><div class="line"><span class="comment">// -2...</span></div><div class="line"><span class="comment">// -1...</span></div><div class="line"><span class="comment">// zero!</span></div></pre></td></tr></table></figure>
<blockquote>
<p>摘自：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" target="_blank" rel="external">swift 官网</a><br>所有代码在Xcode9 Swift4 环境编译没问题，代码<a href="https://github.com/keshiim/LearnSwift4" target="_blank" rel="external">戳这里 https://github.com/keshiim/LearnSwift4</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keshiim.github.io/2017/11/09/Swift-Control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng keshiim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Farmer, keshiim 播种太阳🌞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/09/Swift-Control/" itemprop="url">Swift：控制流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-09T17:01:14+08:00">
                2017-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/09/Swift-Control/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/09/Swift-Control/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/11/09/Swift-Control/" class="leancloud_visitors" data-flag-title="Swift：控制流">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Swift</code> 提供所有多样化的控制流语句。包括 <code>while</code> 循环来多次执行任务； <code>if ， guard 和 switch</code>语句来基于特定的条件执行不同的代码分支；还有比如 <code>break</code> 和 <code>continue</code> 语句来传递执行流到你代码的另一个点上。</p>
<p><code>Swift</code> 同样添加了 <code>for-in</code>循环，它让你更简便地遍历<em>数组、字典、范围和其他序列</em>。</p>
<p><code>Swift</code> 的 <code>switch</code> 语句同样比 <code>C</code> 中的对应语句多了不少新功能。比如说 <code>Swift</code> 中的 <code>switch</code> 语句不再“<strong>贯穿</strong>”到下一个情况当中，这就避免了 <code>C</code> 中常见的 <code>break</code> 语句丢失问题。情况可以匹配<strong>多种模式</strong>，包括<strong>间隔匹配</strong>，<strong>元组</strong>和<strong>特定的类型</strong>。 <code>switch</code> 中匹配的值还能绑定到<em>临时的常量和变量</em>上供情况中代码使用，并且可以为每一个情况写 <code>where</code> 分句表达式来应用复杂条件匹配。</p>
<h3 id="For-in-循环"><a href="#For-in-循环" class="headerlink" title="For-in 循环"></a>For-in 循环</h3><p>使用 <code>for-in</code> 循环来遍历序列，比如一个范围的<em>数字</em>，<em>数组中的元素</em>或者<em>字符串中的字符</em>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个例子使用 for-in 循环来遍历数组中的元素：</span></div><div class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Jack"</span>]</div><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Hello, <span class="subst">\(name)</span>!"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Hello, Anna!</span></div><div class="line"><span class="comment">// Hello, Alex!</span></div><div class="line"><span class="comment">// Hello, Brian!</span></div><div class="line"><span class="comment">// Hello, Jack!</span></div></pre></td></tr></table></figure>
<p>The same as Dictionary，访问它的键值对。当字典遍历时，每一个元素都返回一个 <code>(key, value)</code> 元组，你可以在<code>for-in</code> 循环体中使用显式命名常量来分解 <code>(key, value)</code> 元组成员，当然不想要的值使用<code>_</code>来舍弃值或键。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numberOfLegs = [<span class="string">"spider"</span>: <span class="number">8</span>, <span class="string">"ant"</span>: <span class="number">6</span>, <span class="string">"cat"</span>: <span class="number">4</span>]</div><div class="line"><span class="keyword">for</span> (animalName, legCount) <span class="keyword">in</span> numberOfLegs &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(animalName)</span>s have <span class="subst">\(legCount)</span> legs"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// ants have 6 legs</span></div><div class="line"><span class="comment">// cats have 4 legs</span></div><div class="line"><span class="comment">// spiders have 8 legs</span></div></pre></td></tr></table></figure>
<p><code>for-in</code> 循环同样能遍历数字区间。这个栗子打印了乘五表格的前几行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(index)</span> times 5 is <span class="subst">\(index * <span class="number">5</span>)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1 times 5 is 5</span></div><div class="line"><span class="comment">// 2 times 5 is 10</span></div><div class="line"><span class="comment">// 3 times 5 is 15</span></div><div class="line"><span class="comment">// 4 times 5 is 20</span></div><div class="line"><span class="comment">// 5 times 5 is 25</span></div></pre></td></tr></table></figure>
<p>在上面的栗子当中， <code>index</code> 是一个常量，它的值在每次遍历循环开始的时候被自动地设置。因此，它不需要在使用之前声明。它隐式地在循环的声明中声明了，不需要再用 <code>let</code> 声明关键字。<br>如果你不需要序列的每一个值，你可以使用 <em>下划线</em> ( <code>_</code> )来取代遍历名以<strong>忽略值</strong>。</p>
<p>使用半开区间运算符<code>（ ..&lt; ）</code>来包含最小值但不包含最大值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> minutes = <span class="number">60</span></div><div class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="number">0</span>..&lt;minutes &#123;</div><div class="line">    <span class="comment">// render the tick mark each minute (60 times)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有些用户可能想要在他们的UI上少来点 分钟标记。比如说每 5 分钟一个标记吧。使用 <code>stride(from:to:by:)</code> 函数来跳过不想要的标记。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> minuteInterval = <span class="number">5</span></div><div class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: minutes, by: minuteInterval) &#123;</div><div class="line">    <span class="comment">// render the tick mark every 5 minutes (0, 5, 10, 15 ... 45, 50, 55)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>闭区间也同样适用，使用 <code>stride(from:through:by:)</code> 即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> hours = <span class="number">12</span></div><div class="line"><span class="keyword">let</span> hourInterval = <span class="number">3</span></div><div class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">3</span>, through: hours, by: hourInterval) &#123;</div><div class="line">    <span class="built_in">print</span>(tickMark, terminator: <span class="string">" &gt; "</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//3 &gt; 6 &gt; 9 &gt; 12 &gt;</span></div></pre></td></tr></table></figure>
<h3 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环"></a>While 循环</h3><p><code>while</code> 循环执行一个合集的语句指导条件变成 <code>false</code> 。这种循环最好在第一次循环之后还有未知数量的遍历时使用。<code>Swift</code> 提供了两种 <code>while</code> 循环：</p>
<ul>
<li><code>while</code> <em>在每次循环开始的时候计算它自己的条件；</em></li>
<li><code>repeat-while</code> <em>在每次循环结束的时候计算它自己的条件。</em></li>
</ul>
<h4 id="While"><a href="#While" class="headerlink" title="While"></a>While</h4><p><code>while</code> 循环通过判断单一的条件开始。如果条件为 <code>true</code> ，语句的合集就会重复执行直到条件变为 <code>false</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//while 循环的通用格式：</span></div><div class="line"><span class="keyword">while</span> condition &#123;</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>玩一个玩蛇与梯子（也叫滑梯与梯子）的简单栗子：<br>&lt;: style=’margin: .auto’ src=’snakesAndLadders_2x.png’ alt=’snakesAndLadders_2x’ title=’滑梯与梯子’&gt;</p>
<p>下边是游戏的规则：</p>
<ul>
<li>棋盘拥有 25 个方格，目标就是到达或者超过第 25 号方格；</li>
<li>每一次，你扔一个六面色子，安装方格的数字移动，依据水平的线路，如图安装上边虚线箭头标注的路线；</li>
<li>如果你停留在了梯子的下边，你就可以顺着梯子爬上去；</li>
<li>如果你停留在了蛇的头上，你就要顺着蛇滑下来。</li>
</ul>
<p>游戏棋盘用 <code>Int</code> 值的数组来表示。它的大小基于一个叫做 <code>finalSquare</code> 的常量，它被用来初始化数组同样用来检测稍后的胜利条件。棋盘使用 26 个零 <code>Int</code> 值初始化，而不是 25 个（从 0  到 25 ）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> finalSquare = <span class="number">25</span></div><div class="line"><span class="keyword">var</span> board = [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: finalSquare + <span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>随后设置为拥有更多特定的值比如蛇和梯子。有梯子的方格有一个正数来让你移动到棋盘的上方，因此有蛇的方格有一个负数来让你从棋盘上倒退：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">board[<span class="number">03</span>] = +<span class="number">08</span>; board[<span class="number">06</span>] = +<span class="number">11</span>; board[<span class="number">09</span>] = +<span class="number">09</span>; board[<span class="number">10</span>] = +<span class="number">02</span></div><div class="line">board[<span class="number">14</span>] = -<span class="number">10</span>; board[<span class="number">19</span>] = -<span class="number">11</span>; board[<span class="number">22</span>] = -<span class="number">02</span>; board[<span class="number">24</span>] = -<span class="number">08</span></div></pre></td></tr></table></figure>
<p>玩家从“零格”开始，它正好是棋盘的左下角。第一次扔色子总会让玩家上到棋盘上去：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> square = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> diceRoll = <span class="number">0</span></div><div class="line"><span class="keyword">while</span> square &lt; finalSquare &#123;</div><div class="line">    <span class="comment">//roll the dice</span></div><div class="line">    diceRoll += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> diceRoll == <span class="number">7</span> &#123;</div><div class="line">        diceRoll = <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//move by the rolled amount</span></div><div class="line">    square += diceRoll</div><div class="line">    <span class="keyword">if</span> square &lt; board.<span class="built_in">count</span> &#123;</div><div class="line">        <span class="comment">// if we`re still on the board, move up or down for a snake or a ladder</span></div><div class="line">        square += board[square];</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"now: <span class="subst">\(square)</span>"</span>, terminator: <span class="string">"&gt; "</span>)</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"Game over!"</span>)</div><div class="line"><span class="comment">//print now: 1&gt; now: 11&gt; now: 4&gt; now: 8&gt; now: 13&gt; now: 8&gt; now: 18&gt; now: 20&gt; now: 23&gt; now: 27&gt; Game over!</span></div></pre></td></tr></table></figure>
<p>当前的 <code>while</code> 循环执行结束，并且循环条件已经检查来看循环是否应该再次执行。如果玩家已经移到或者超出了第 25 号方格，循环评定为 <code>false</code> ，游戏就结束了。</p>
<p><code>while</code> 循环在这个情况当中合适是因为开始 <code>while</code> 循环之后游戏的长度并不确定。循环会一直执行下去直到特定的条件不满足。</p>
<h4 id="Repeat-While"><a href="#Repeat-While" class="headerlink" title="Repeat-While"></a>Repeat-While</h4><p><code>while</code> 循环的另一种形式，就是所谓的 <code>repeat-while</code> 循环，在判断循环条件之前会执行一次循环代码块。然后会继续重复循环直到条件为 <code>false</code> 。</p>
<p><code>repeat-while</code> 循环的通用形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">repeat</span> &#123;</div><div class="line">    statements</div><div class="line">&#125; <span class="keyword">while</span> condiation</div></pre></td></tr></table></figure>
<p>再次回顾蛇与梯子的栗子，使用 <code>repeat-while</code> 循环而不是 <code>while</code> 循环。 <code>finalSquare , board , square , 和 diceRoll</code>的值初始化的方式与 <code>while</code> 循环完全相同：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> finalSquare = <span class="number">25</span></div><div class="line"><span class="keyword">var</span> board = [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: finalSquare + <span class="number">1</span>)</div><div class="line">board[<span class="number">03</span>] = +<span class="number">08</span>; board[<span class="number">06</span>] = +<span class="number">11</span>; board[<span class="number">09</span>] = +<span class="number">09</span>; board[<span class="number">10</span>] = +<span class="number">02</span></div><div class="line">board[<span class="number">14</span>] = -<span class="number">10</span>; board[<span class="number">19</span>] = -<span class="number">11</span>; board[<span class="number">22</span>] = -<span class="number">02</span>; board[<span class="number">24</span>] = -<span class="number">08</span></div><div class="line"><span class="keyword">var</span> square = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> diceRoll = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>在这个版本的游戏中，第一次循环中的动作是用来检查梯子或者蛇的。没有梯子能直接把玩家带到25格，因此不可能通过梯子赢得游戏。也就是说，在循环一开始就检查蛇还是梯子是安全的。<br>游戏一开始，玩家在“零格”。 <code>board[0]</code> 总是等于 <code>0</code> 的，并且没有效果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">square = <span class="number">0</span></div><div class="line">diceRoll = <span class="number">0</span></div><div class="line"><span class="keyword">repeat</span> &#123;</div><div class="line">    <span class="comment">// move up or down for a snake or ladder</span></div><div class="line">    square += board[square]</div><div class="line">    <span class="comment">// roll the dice</span></div><div class="line">    diceRoll += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> diceRoll = <span class="number">7</span> &#123;</div><div class="line">        diceRoll = <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// move by the rolled amount</span></div><div class="line">    square += diceRoll</div><div class="line">    <span class="built_in">print</span>(<span class="string">"now: <span class="subst">\(square)</span>"</span>, terminator: <span class="string">"&gt; "</span>)</div><div class="line">&#125; <span class="keyword">while</span> square &lt; finalSquare</div><div class="line"><span class="comment">//now: 1&gt; now: 3&gt; now: 14&gt; now: 8&gt; now: 13&gt; now: 19&gt; now: 9&gt; now: 20&gt; now: 23&gt; now: 27&gt; Game over!</span></div></pre></td></tr></table></figure>
<p>在检查是蛇还是梯子的代码之后，就是要色子了，玩家按照 <code>diceRoll</code> 数量的格数前进。当前循环执行结束。<br>循环条件 <code>( while square &lt; finalSquare)</code>  与之前的相同，但是这次它会在第一次循环结束之后才会被判定。 <code>repeat-while</code> 循环的结构要比前边栗子里的 <code>while</code> 循环更适合这个游戏。在上边的 <code>repeat-while</code> 循环中， <code>square += board[square]</code> 总是会在循环的 <code>while</code> 条件确定 <code>square</code> 仍在棋盘上之后立即执行。这个行为就去掉了早期游戏版本中对数组边界检查的需要。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>很多时候根据特定的条件来执行不同的代码是很有用的。你可能想要在错误发生时运行额外的代码，或者当值变得太高或者太低的时候显示一条信息。要达成这个目的，你可以让你的那部分代码<strong>有条件地</strong>执行。</p>
<p><code>Swift</code> 提供了两种方法来给你的代码添加条件分支，就是所谓的 <code>if</code> 语句和 <code>switch</code> 语句。总的来说，你可以使用 <code>if</code> <em>语句来判定简单的条件</em>，比如少量的可能性。 <code>switch</code> <em>语句则适合更复杂的条件</em>，比如多个可能的组合，并且在模式匹配的情况下更加有用，可以帮你选择一段合适的代码分支来执行。</p>
<h4 id="If"><a href="#If" class="headerlink" title="If"></a>If</h4><p>最简单的形式中， <code>if</code> 语句有着一个单一的 <code>if</code> 条件。它只会在条件为 <code>true</code> 的情况下才会执行语句的集合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> temperatureInFahrenheit = <span class="number">30</span></div><div class="line"><span class="keyword">if</span> temperatureInFahrenheit &lt;= <span class="number">32</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"It`s very cold. Consider wearing a scarf."</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"It`s not that cold. Wear a t-shirt."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//prints "It's not that cold. Wear a t-shirt."</span></div></pre></td></tr></table></figure>
<p>先前的栗子检测了温度是否小于等于 32 华氏温度（水的冰点）。如果是，就打印一个信息。否则，没有信息打印，并且执行 <code>if</code> 语句的大括号后边的代码，如果温度大于32华氏温度，会执行<em><code>else</code> 分句</em>。</p>
<h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h4><p><code>switch</code> 语句会将一个值与多个可能的<strong>模式匹配</strong>。然后基于第一个成功匹配的模式来执行合适的代码块。 <code>switch</code> 语句代替 <code>if</code> 语句提供了对多个潜在状态的响应。</p>
<p>在其自身最简单的格式中， <code>switch</code> 语句把一个值与一个或多个相同类型的值比较：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> some value to consider &#123;</div><div class="line"><span class="keyword">case</span> value <span class="number">1</span>:</div><div class="line">    respond to value <span class="number">1</span></div><div class="line"><span class="keyword">case</span> value <span class="number">2</span>,</div><div class="line">value <span class="number">3</span>:</div><div class="line">    respond to value <span class="number">2</span> or <span class="number">3</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">    otherwise, <span class="keyword">do</span> something <span class="keyword">else</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="没有隐式贯穿"><a href="#没有隐式贯穿" class="headerlink" title="没有隐式贯穿"></a>没有隐式贯穿</h5><p>相比 <code>C</code> 和 <code>Objective-C</code>里的 <code>switch</code> 语句来说，<code>Swift</code> 里的 <code>switch</code> <em>语句不会默认从每个情况的末尾贯穿到下一个情况里</em>。相反，整个 <code>switch</code> 语句会在匹配到第一个 <code>switch</code> 情况执行完毕之后退出，不再需要显式的 <code>break</code> 语句。这使得 <code>switch</code> 语句比 <code>C</code> 的更安全和易用，并且避免了意外地执行多个 <code>switch</code> 情况。</p>
<blockquote>
<p>尽管 <code>break</code> 在 Swift 里不是必须的，你仍然可以使用 <code>break</code> 语句来匹配和忽略特定的情况，或者在某个情况执行完成之前就打断它。</p>
</blockquote>
<p>每一个情况的函数体<strong>必须</strong>包含至少<em>一个可执行的语句</em>。下面的代码就是不正确的，因为第一个情况是空的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> = <span class="string">"a"</span></div><div class="line"><span class="keyword">switch</span> anotherCharacter &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">"a"</span>:</div><div class="line"><span class="keyword">case</span> <span class="string">"A"</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The letter A"</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Not the letter A"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// this will report a compile-time error</span></div></pre></td></tr></table></figure>
<p>与 C 中的 <code>switch</code> 语句不同，这个 <code>switch</code> 语句没有同时匹配 ”a” 和 ”A” 。相反它会导致一个编译时错误 <code>case “a”:</code><strong>没有包含任何可执行语句</strong> 。这可以避免意外地从一个情况贯穿到另一个情况中，并且让代码更加安全和易读。</p>
<p>在一个 <code>switch</code> 情况中匹配多个值可以用逗号分隔，并且可以写成多行，如果列表太长的话：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> = <span class="string">"a"</span></div><div class="line"><span class="keyword">switch</span> anotherCharacter &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"A"</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The letter A"</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Not the letter A"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Prints "The letter A"</span></div></pre></td></tr></table></figure>
<h5 id="区间匹配"><a href="#区间匹配" class="headerlink" title="区间匹配"></a>区间匹配</h5><p><code>switch</code>情况的值可以在一个区间中匹配。这个栗子使用了数字区间来为语言中的数字区间进行转换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> approximateCount = <span class="number">62</span></div><div class="line"><span class="keyword">let</span> countedThings = <span class="string">"moons orbiting Saturn"</span></div><div class="line"><span class="keyword">var</span> naturalCount: <span class="type">String</span></div><div class="line"><span class="keyword">switch</span> approximateCount &#123;</div><div class="line"><span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">    naturalCount = <span class="string">"no"</span></div><div class="line"><span class="keyword">case</span> <span class="number">1</span>..&lt;<span class="number">5</span>:</div><div class="line">    naturalCount = <span class="string">"a few"</span></div><div class="line"><span class="keyword">case</span> <span class="number">5</span>..&lt;<span class="number">12</span>:</div><div class="line">    naturalCount = <span class="string">"several"</span></div><div class="line"><span class="keyword">case</span> <span class="number">12</span>..&lt;<span class="number">100</span>:</div><div class="line">    naturalCount = <span class="string">"dozens of"</span></div><div class="line"><span class="keyword">case</span> <span class="number">100</span>..&lt;<span class="number">1000</span>:</div><div class="line">    naturalCount = <span class="string">"hundreds of"</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">    naturalCount = <span class="string">"many"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"There are <span class="subst">\(naturalCount)</span> <span class="subst">\(countedThings)</span>."</span>)</div></pre></td></tr></table></figure>
<p>在上面的栗子中， <code>approximateCount</code>  在 <code>switch</code> 语句中进行评定。每个 <code>case</code> 都与数字或者区间进行对比。由于 <code>approximateCount</code> 的值在12和100之间， <code>naturalCount</code> 被赋值 <code>“dozens of”</code>，并且执行结果传递出了 <code>switch</code> 语句。</p>
<h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><p>你可以使用元组来在一个 <code>switch</code> 语句中测试多个值。每个元组中的元素都可以与<strong>不同</strong>的<em>值</em>或者<em>区间</em>进行匹配。另外，使用下划线<code>（_）</code>来表明匹配<strong>所有可能的值</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> somePoint = (<span class="number">1</span>, <span class="number">1</span>)</div><div class="line"><span class="keyword">switch</span> somePoint &#123;</div><div class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"(0, 0) is at the origin"</span>)</div><div class="line"><span class="keyword">case</span> (<span class="number">_</span>, <span class="number">0</span>):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(somePoint.<span class="number">0</span>)</span>, 0) is on the x-axis"</span>)</div><div class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">_</span>):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"(0, <span class="subst">\(somePoint.<span class="number">1</span>)</span>) is on the y-axis"</span>)</div><div class="line"><span class="keyword">case</span> (-<span class="number">2</span>...<span class="number">2</span>, -<span class="number">2</span>...<span class="number">2</span>):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(somePoint.<span class="number">0</span>)</span>, <span class="subst">\(somePoint.<span class="number">1</span>)</span>) is inside the box"</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(somePoint.<span class="number">0</span>)</span>, <span class="subst">\(somePoint.<span class="number">1</span>)</span>) is outside the box"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints "(1, 1) is inside the box"</span></div></pre></td></tr></table></figure>
<p><code>switch</code> 语句决定坐标是否在原点 <code>(0,0)</code> ；在红色的 x 坐标轴；在橘黄色的 y坐标轴；在蓝色的4乘4以原点为中心的方格里；或者在方格外边。</p>
<p><img style="margin: .auto" src="/2017/11/09/Swift-Control/coordinateGraphSimple_2x.png" alt="coordinateGraphSimple_2x" title="表示区间(1)"></p>
<h5 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h5><p><code>switch</code> 情况可以将匹配到的<strong>值*</strong>临时绑定<em>为一个</em>常量或者变量<em>，来给情况的函数体使用。这就是所谓的</em>值绑定*，因为值是在情况的函数体里“绑定”到临时的常量或者变量的。</p>
<p>下边的栗子接收一个<em> (x,y)</em> 坐标，使用 <em>(Int,Int)</em> 元组类型并且在下边的图片里显示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> anotherPoint = (<span class="number">2</span>, <span class="number">0</span>)</div><div class="line"><span class="keyword">switch</span> anotherPoint &#123;</div><div class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"on the x-axis with an x value of <span class="subst">\(x)</span>"</span>)</div><div class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"on the y-axis with a y value of <span class="subst">\(y)</span>"</span>)</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"somewhere else at (<span class="subst">\(x)</span>, <span class="subst">\(y)</span>)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// print:on the x-axis with an x value of 2</span></div></pre></td></tr></table></figure>
<p><img style="margin: .auto" src="/2017/11/09/Swift-Control/coordinateGraphMedium_2x.png" alt="coordinateGraphMedium_2x" title="表示区间（2）"></p>
<p><code>switch</code> 语句决定坐标是否在在红色的x坐标轴，在橘黄色的y坐标轴；还是其他地方；或不在坐标轴上。</p>
<p>三个 <code>switch</code> 情况都使用了常量占位符 x 和 y ，它会从临时 <code>anotherPoint</code> 获取一个或者两个元组值。第一个情况， <code>case(let x, 0)</code>，匹配任何 y 的值是 0 并且赋值坐标的x到临时常量 x 里。类似地，第二个情况， <code>case(0,let y)</code> ，匹配让后 x 值是 0 并且把 y 的值赋值给临时常量 y 。</p>
<p><strong>在临时常量被声明后，它们就可以在情况的代码块里使用</strong>。这里，它们用来输出点的分类。</p>
<p>注意这个 switch 语句没有任何的 <code>default</code> 情况。最后的情况， <code>case let (x,y)</code> ，声明了一个带有<em>两个占位符常量的元组</em>，它可以匹配所有的值。结果，它匹配了所有剩下的值，然后就不需要 <code>default</code> 情况来让 <code>switch</code> 语句穷尽了。</p>
<h5 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h5><p><code>switch</code> 情况可以使用 <code>where</code> 分句来检查额外的情况。<br>下边的栗子划分 <code>(x,y)</code> 坐标到下边的图例中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> yetAnotherPoint = (<span class="number">1</span>, -<span class="number">1</span>)</div><div class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == y:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == y"</span>)</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == -y:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == -y"</span>)</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is just some arbitrary point"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints "(1, -1) is on the line x == -y"</span></div></pre></td></tr></table></figure>
<p><img style="margin: .auto" src="/2017/11/09/Swift-Control/coordinateGraphComplex_2x.png" alt="coordinateGraphComplex_2x" title="表示区间（3）"></p>
<p>三个 <code>switch</code> 情况声明了占位符常量 x 和 y ，它从 <code>yetAnotherPoint</code> 临时接收两个元组值。这个常量使用 <code>where</code> 分句，来创建动态过滤。 <code>switch</code> 情况只有 <code>where</code> 分句情况评定等于 <code>true</code> 时才会匹配这个值。</p>
<p>和前边的栗子一样，最后的情况匹配了余下所有可能的值，所以不需要 <code>default</code> 情况这个 <code>switch</code> 也是全面的。</p>
<h6 id="复合情况"><a href="#复合情况" class="headerlink" title="复合情况"></a>复合情况</h6><p>多个 <code>switch</code> 共享同一个函数体的多个情况可以在 <code>case</code> 后写多个模式来复合，在每个模式之间用逗号分隔。如果任何一个模式匹配了，那么这个情况都会被认为是匹配的。如果模式太长，可以把它们写成多行，比如说：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> someCharacter: <span class="type">Character</span> = <span class="string">"e"</span></div><div class="line"><span class="keyword">switch</span> someCharacter &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(someCharacter)</span> is a vowel"</span>)</div><div class="line"><span class="keyword">case</span> <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>, <span class="string">"m"</span>,</div><div class="line">     <span class="string">"n"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(someCharacter)</span> is a consonant"</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(someCharacter)</span> is not a vowel or a consonant"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Prints "e is a vowel"</span></div></pre></td></tr></table></figure>
<p><em>复合情况</em>同样可以包含<strong>值绑定</strong>。所有复合情况的模式都<em>必须包含相同的值绑定集合</em>，并且复合情况中的每一个绑定都得有<em>相同的类型格式</em>。这才能确保无论复合情况的那部分匹配了，接下来的函数体中的代码都能访问到绑定的值并且值的类型也都相同。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> stillAnotherPoint = (<span class="number">9</span>, <span class="number">0</span>)</div><div class="line"><span class="keyword">switch</span> stillAnotherPoint &#123;</div><div class="line"><span class="keyword">case</span> (<span class="keyword">let</span> <span class="built_in">distance</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="keyword">let</span> <span class="built_in">distance</span>):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"On an axis, <span class="subst">\(<span class="built_in">distance</span>)</span> from the origin"</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Not on an axis"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Prints "On an axis, 9 from the origin"</span></div></pre></td></tr></table></figure>
<p>上边的 <code>case</code> 拥有两个模式：  <code>(let distance, 0)</code> 匹配 x 轴的点以及 <code>(0, let distance)</code> 匹配 y 轴的点。两个模式都包含一个 <code>distance</code> 的绑定并且 <code>distance</code> 在两个模式中都是整形——也就是说这个 <code>case</code> 函数体的代码一定可以访问 <code>distance</code> 的值。</p>
<h3 id="控制转移语句"><a href="#控制转移语句" class="headerlink" title="控制转移语句"></a>控制转移语句</h3><p>控制转移语句在你代码执行期间改变代码的执行顺序，通过从一段代码转移控制到另一段。Swift 拥有五种控制转移语句：</p>
<ul>
<li>continue</li>
<li>break</li>
<li>fallthrough</li>
<li>return</li>
<li>throw</li>
</ul>
<p><code>continue</code> , <code>break</code> , 和 <code>fallthrough</code>  语句在下边有详细描述。 <code>return</code> 语句在函数中描述，还有 <code>throw</code> 语句在使用抛出函数传递错误中描述。</p>
<h4 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h4><p><code>continue</code> 语句告诉循环停止正在做的事情并且再次从头开始循环的下一次遍历。它是说“我不再继续当前的循环遍历了”而不是离开整个的循环。<br>举个栗子🌰：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> puzzleInput = <span class="string">"great minds think alike"</span></div><div class="line"><span class="keyword">var</span> puzzleOutput = <span class="string">""</span></div><div class="line"><span class="keyword">for</span> character <span class="keyword">in</span> puzzleInput.characters &#123;</div><div class="line">    <span class="keyword">switch</span> character &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>, <span class="string">" "</span>:</div><div class="line">        <span class="keyword">continue</span></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        puzzleOutput.append(character)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(puzzleOutput)</div><div class="line"><span class="comment">// prints "grtmndsthnklk"</span></div></pre></td></tr></table></figure>
<p>上面的代码在匹配到元音或者空格的时候调用了 <code>continue</code> 关键字，导致遍历的当前循环立即结束并直接跳到了下一次遍历的开始。这个行为使得 <code>switch</code> 代码块匹配（和忽略）只有元音和空格的字符，而不是请求匹配每一个要打印的字符。</p>
<h4 id="Break"><a href="#Break" class="headerlink" title="Break"></a>Break</h4><p><code>break</code> 语句会立即结束整个控制流语句。当你想要提前结束 <code>switch</code> 或者循环语句或者其他情况时可以在 <code>switch</code> 语句或者循环语句中使用 <code>break</code> 语句。</p>
<h5 id="循环语句中的-Break"><a href="#循环语句中的-Break" class="headerlink" title="循环语句中的 Break"></a>循环语句中的 Break</h5><p>当在循环语句中使用时， <code>break</code> 会立即结束循环的执行，并且转移控制到循环结束花括号（ } ）后的第一行代码上。当前遍历循环里的其他代码都不会被执行，并且余下的遍历循环也不会开始了。</p>
<h5 id="Switch-语句里的-Break"><a href="#Switch-语句里的-Break" class="headerlink" title="Switch 语句里的 Break"></a>Switch 语句里的 Break</h5><p>当在<code>switch</code>语句里使用时， <code>break</code> 导致 <code>switch</code> 语句立即结束它的执行，并且转移控制到 <code>switch</code> 语句结束花括号（ } ）之后的第一行代码上。</p>
<p>这可以用来在一个 <code>switch</code> 语句中匹配和忽略一个或者多个情况。因为 Swift 的 <code>switch</code> 语句是<strong>穷尽且不允许空情况的</strong>，所以有时候有必要故意匹配和忽略一个匹配到的情况以让你的意图更加明确。要这样做的话你可以通过把 <code>break</code> 语句作为情况的整个函数体来忽略某个情况。当这个情况通过 <code>switch</code> 语句匹配到了，情况中的 <code>break</code> 语句会立即结束 <code>switch</code> 语句的执行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numberSymbol: <span class="type">Character</span> = <span class="string">"三"</span>  <span class="comment">// Simplified Chinese for the number 3</span></div><div class="line"><span class="keyword">var</span> possibleIntegerValue: <span class="type">Int</span>?</div><div class="line"><span class="keyword">switch</span> numberSymbol &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">"1"</span>, <span class="string">"١"</span>, <span class="string">"一"</span>, <span class="string">"๑"</span>:</div><div class="line">    possibleIntegerValue = <span class="number">1</span></div><div class="line"><span class="keyword">case</span> <span class="string">"2"</span>, <span class="string">"٢"</span>, <span class="string">"二"</span>, <span class="string">"๒"</span>:</div><div class="line">    possibleIntegerValue = <span class="number">2</span></div><div class="line"><span class="keyword">case</span> <span class="string">"3"</span>, <span class="string">"٣"</span>, <span class="string">"三"</span>, <span class="string">"๓"</span>:</div><div class="line">    possibleIntegerValue = <span class="number">3</span></div><div class="line"><span class="keyword">case</span> <span class="string">"4"</span>, <span class="string">"٤"</span>, <span class="string">"四"</span>, <span class="string">"๔"</span>:</div><div class="line">    possibleIntegerValue = <span class="number">4</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="keyword">break</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> integerValue = possibleIntegerValue &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The integer value of <span class="subst">\(numberSymbol)</span> is <span class="subst">\(integerValue)</span>."</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"An integer value could not be found for <span class="subst">\(numberSymbol)</span>."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints "The integer value of 三 is 3."</span></div></pre></td></tr></table></figure>
<p>在上边的例子中，列举所有可能的 <code>Character</code> 值是不实际的，所以<code>default</code>情况就提供了一个匹配所有没有匹配到的字符的功能。这个 <code>default</code> 情况不需要执行任何动作，所以因此就写了一个 <code>break</code> 语句作为函数体。一旦 <code>default</code> 情况匹配到了， <code>break</code> 语句结束 <code>switch</code> 语句的执行，然后代码从 <code>if let</code> 语句继续执行。</p>
<h5 id="Fallthrough"><a href="#Fallthrough" class="headerlink" title="Fallthrough"></a>Fallthrough</h5><p><code>swift</code>贯穿。<br>如果你确实需要 <code>C</code> 风格的贯穿行为，你可以选择在每个情况末尾使用 <code>fallthrough</code> 关键字。下面的栗子使用了 <code>fallthrough</code> 来创建一个数字的文字描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> integerToDescribe = <span class="number">5</span></div><div class="line"><span class="keyword">var</span> description = <span class="string">"The number <span class="subst">\(integerToDescribe)</span> is"</span></div><div class="line"><span class="keyword">switch</span> integerToDescribe &#123;</div><div class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</div><div class="line">    description += <span class="string">" a prime number, and also"</span></div><div class="line">    <span class="keyword">fallthrough</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">    description += <span class="string">" an integer."</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(description)</div><div class="line"><span class="comment">// prints "The number 5 is a prime number, and also an integer."</span></div></pre></td></tr></table></figure>
<p>这个栗子声明了一个新的 <code>String</code> 变量叫做 <code>description</code> 并且赋值给它一个初始值。然后函数使用一个 <code>switch</code> 语句来判断 <code>integerToDescribe</code> 。如果 <code>integerToDescribe</code> 是一个列表中的质数，函数就在 <code>description</code> 的末尾追加文字，来标记这个数字是质数。然后它使用 <code>fallthrough</code> 关键字来“贯穿到” <code>default</code> 情况。 <code>default</code> 情况添加额外的文字到描述的末尾，接着 <code>switch</code> 语句结束。</p>
<h5 id="给语句打标签"><a href="#给语句打标签" class="headerlink" title="给语句打标签"></a>给语句打标签</h5><p>你可以内嵌循环和条件语句到其他循环和条件语句当中以在 Swift 语言中创建一个复杂的控制流结构。总之，循环和条件语句都可以使用 <code>break</code> 语句来提前结束它们的执行。因此，显式地标记那个循环或者条件语句是你想用 <code>break</code> 语句结束的就很有必要。同样的，<strong>如果你有多个内嵌循环，显式地标记你想让 <code>continue</code> 语句生效的是哪个循环就很有必要了。</strong></p>
<p>要达到这些目的，你可以用<strong>语句标签</strong>来给循环语句或者条件语句做<em>标记</em>。在一个条件语句中，你可以使用一个语句标签配合 <code>break</code> 语句来结束被标记的语句。在循环语句中，你可以使用语句标签来配合 <code>break</code> 或者 <code>continue</code> 语句来结束或者继续执行被标记的语句。</p>
<p><em>通过把标签作为关键字放到语句开头来用标签标记一段语句</em>，后跟<strong>冒号</strong>。这里是一个对 <code>while</code> 循环使用标签的栗子，这个原则对所有的循环和 <code>switch</code> 语句来说都相同：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(label name): <span class="keyword">while</span> condition &#123;</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下边的栗子为你之前章节看过的<em>蛇与梯子游戏</em>做了修改，在 <code>while</code> 循环中使用了标签来配合 <code>break</code> 和 <code>continue</code> 语句。这次，这个游戏有一个额外的规则：</p>
<ul>
<li>要赢得游戏，你必须精确地落在第25格上。<br>如果特定的点数带你超过了第25格，你必须再次掷色子直到你恰好得到了落到第25格的点数。</li>
</ul>
<p>游戏棋盘与之前的一样：<br><img style="margin: .auto" src="/2017/11/09/Swift-Control/snakesAndLadders_2x(1).png" alt="snakesAndLadders_2x(1)" title="蛇和梯子游戏示意图"><br><code>finalSquare ， board ， square 和 diceRoll</code> 的值也用和之前一样的方式来初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> finalSquare = <span class="number">25</span></div><div class="line"><span class="keyword">var</span> board = [<span class="type">Int</span>](<span class="built_in">count</span>: finalSquare + <span class="number">1</span>, repeatedValue: <span class="number">0</span>)</div><div class="line">board[<span class="number">03</span>] = +<span class="number">08</span>; board[<span class="number">06</span>] = +<span class="number">11</span>; board[<span class="number">09</span>] = +<span class="number">09</span>; board[<span class="number">10</span>] = +<span class="number">02</span></div><div class="line">board[<span class="number">14</span>] = -<span class="number">10</span>; board[<span class="number">19</span>] = -<span class="number">11</span>; board[<span class="number">22</span>] = -<span class="number">02</span>; board[<span class="number">24</span>] = -<span class="number">08</span></div><div class="line"><span class="keyword">var</span> square = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> diceRoll = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>这个版本的游戏使用了一个 <code>while</code> 循环和一个 <code>switch</code> 语句来实现游戏的逻辑。 <code>while</code> 循环有一个叫做 <code>gameLoop</code> 的标签，来表明它是蛇与梯子游戏的主题循环。</p>
<p><code>while</code> 循环条件是 <code>while square != finaleSquare</code> ，用来反映你必须精确地落在第25格上：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">gameLoop: <span class="keyword">while</span> square != finalSquare &#123;</div><div class="line">    diceRoll += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> diceRoll == <span class="number">7</span> &#123; diceRoll = <span class="number">1</span> &#125;</div><div class="line">    <span class="keyword">switch</span> square + diceRoll &#123;</div><div class="line">    <span class="keyword">case</span> finalSquare:</div><div class="line">        <span class="comment">// diceRoll will move us to the final square, so the game is over</span></div><div class="line">        <span class="keyword">break</span> gameLoop</div><div class="line">    <span class="keyword">case</span> <span class="keyword">let</span> newSquare <span class="keyword">where</span> newSquare &gt; finalSquare:</div><div class="line">        <span class="comment">// diceRoll will move us beyond the final square, so roll again</span></div><div class="line">        <span class="keyword">continue</span> gameLoop</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="comment">// this is a valid move, so find out its effect</span></div><div class="line">        square += diceRoll</div><div class="line">        square += board[square]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"Game over!"</span>)</div></pre></td></tr></table></figure>
<p>每次循环，都会扔色子。使用一个 <code>switch</code> 语句来考虑移动的结果而不是立即移动玩家，然后如果移动允许的话就工作：</p>
<ul>
<li><p>如果扔的色子将把玩家移动到最后的方格，游戏就结束。 <code>break</code> <code>gameLoop</code> 语句转移控制到 <code>while</code> 循环外的第一行代码上，它会结束游戏。</p>
</li>
<li><p>如果扔的色子点数将会把玩家移动超过最终的方格，那么移动就是不合法的，玩家就需要再次扔色子。 <code>continue gameLoop</code> 语句就会结束当前的 <code>while</code> 循环遍历并且开始下一次循环的遍历。</p>
</li>
<li><p>在其他所有的情况中，色子是合法的。玩家根据 <code>diceRoll</code> 的方格数前进，并且游戏的逻辑会检查蛇和梯子。然后循环结束，控制返回到 <code>while</code> 条件来决定是否要再次循环。</p>
</li>
</ul>
<h3 id="提前退出"><a href="#提前退出" class="headerlink" title="提前退出"></a>提前退出</h3><p><code>guard</code> 语句，类似于 <code>if</code> 语句，基于布尔值表达式来执行语句。使用 <code>guard</code> 语句来要求一个条件必须是真才能执行 <code>guard</code> 之后的语句。与 <code>if</code> 语句不同， <code>guard</code> 语句<strong>总是有一个 <code>else</code> 分句</strong>—— <code>else</code> 分句里的代码会在条件不为真的时候执行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> person: [String: String])</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = person[<span class="string">"name"</span>] <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">print</span>(<span class="string">"Hello <span class="subst">\(name)</span>!"</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> location = person[<span class="string">"location"</span>] <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"I hope the weather is nice near you."</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">print</span>(<span class="string">"I hope the weather is nice in <span class="subst">\(location)</span>."</span>)</div><div class="line">&#125;</div><div class="line">greet([<span class="string">"name"</span>: <span class="string">"John"</span>])</div><div class="line"><span class="comment">// prints "Hello John!"</span></div><div class="line"><span class="comment">// prints "I hope the weather is nice near you."</span></div><div class="line">greet([<span class="string">"name"</span>: <span class="string">"Jane"</span>, <span class="string">"location"</span>: <span class="string">"Cupertino"</span>])</div><div class="line"><span class="comment">// prints "Hello Jane!"</span></div><div class="line"><span class="comment">// prints "I hope the weather is nice in Cupertino."</span></div></pre></td></tr></table></figure>
<p>如果 <code>guard</code> 语句的条件被满足，代码会继续执行直到 <code>guard</code> 语句后的花括号。任何在条件中使用可选项绑定而赋值的变量或者常量在 <code>guard</code> 所在的代码块中<em>随后的代码里都是**</em>可用的**。</p>
<p>如果这个条件没有被满足，那么在 <code>else</code> 分支里的代码就会被执行。这个分支必须转移控制结束 <code>guard</code> 所在的代码块。要这么做可以使用控制转移语句比如 <code>return ， break ， continue 或者 throw</code> ，或者它可以调用一个不带有返回值的函数或者方法，比如 <code>fatalError()</code> 。</p>
<h3 id="检查API的可用性"><a href="#检查API的可用性" class="headerlink" title="检查API的可用性"></a>检查API的可用性</h3><p>Swift 拥有内置的对 API 可用性的检查功能，它能够确保你不会悲剧地使用了对部属目标不可用的 API。</p>
<p>编译器在 SDK 中使用可用性信息来确保在你项目中明确的 API 都是可用的。如果你尝试使用一个不可用的 API 的话，Swift 会在编译时报告一个错误。</p>
<p>你可以在 <code>if</code> 或者 <code>guard</code> 语句中使用一个可用性条件来有条件地执行代码，基于在运行时你想用的哪个 API 是可用的。当验证在代码块中的 API 可用性时，编译器使用来自可用性条件里的信息来检查。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> #available(iOS <span class="number">10</span>, macOS <span class="number">10.12</span>, *) &#123;</div><div class="line">    <span class="comment">// Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Fall back to earlier iOS and macOS APIs</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上边的可用性条件确定了在 iOS 平台， <code>if</code> 函数体只在 <em>iOS 10</em> 及以上版本才会执行；对于 macOS 平台，在只有在 <code>macOS 10.12</code> 及以上版本才会运行。最后一个实际参数， <code>*</code> ，它需求并表明在其他所有平台， <code>if</code> 函数体执行你在目标里明确的最小部属。</p>
<blockquote>
<p>摘自：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" target="_blank" rel="external">swift 官网</a><br>所有代码在Xcode9 Swift4 环境编译没问题，代码<a href="https://github.com/keshiim/LearnSwift4" target="_blank" rel="external">戳这里 https://github.com/keshiim/LearnSwift4</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keshiim.github.io/2017/10/30/swift-collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng keshiim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Farmer, keshiim 播种太阳🌞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/30/swift-collection/" itemprop="url">Swift：集合类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-30T15:16:57+08:00">
                2017-10-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/30/swift-collection/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/30/swift-collection/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/10/30/swift-collection/" class="leancloud_visitors" data-flag-title="Swift：集合类">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Swift</code> 提供了三种主要的集合类型，所谓的数组、合集还有字典，用来储存值的集合。数组是有序的值的集合。合集是唯一值的无序集合。字典是无序的键值对集合。<br><img style="margin: .auto," src="/2017/10/30/swift-collection/CollectionTypes_intro_2x.png" ,="" alt="CollectionTypes_intro_2x.png" title="CollectionTypes_介绍"></p>
<p><code>Swift</code> 中的数组、合集和字典总是明确能储存的值的类型以及它们能储存的键。就是说你不会意外地插入一个错误类型的值到集合中去。它同样意味着你可以从集合当中取回确定类型的值。</p>
<blockquote>
<p><code>Swift</code> 的数组、合集和字典是以泛型集合实现的。</p>
</blockquote>
<h3 id="集合的可变性"><a href="#集合的可变性" class="headerlink" title="集合的可变性"></a>集合的可变性</h3><p>如果你创建一个<em>数组</em>、<em>合集</em>或者<em>一个字典</em>，并且赋值给一个变量，那么创建的集合就是<strong>可变的</strong>。这意味着你随后可以通过<strong>添加、移除、或者改变集合中</strong>的元素来改变（或者说异变）集合。如果你把数组、合集或者字典赋值给一个常量，则集合就成了<strong>不可变的</strong>，它的<em>大小</em>和<em>内容</em>都不能被改变。</p>
<blockquote>
<p>集合不需要改变的情况下创建不可变集合是个不错的选择。这样做可以允许 Swift 编译器优化你创建的集合的性能。</p>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组以有序的方式来储存相同类型的值。相同类型的值可以在数组的不同地方多次出现。</p>
<blockquote>
<p><code>Swift</code> 的 <code>Array</code>类型被桥接到了基础框架的 <code>NSArray</code>类上。</p>
</blockquote>
<h4 id="数组类型简写语法"><a href="#数组类型简写语法" class="headerlink" title="数组类型简写语法"></a>数组类型简写语法</h4><p><code>Swift</code> 数组的类型<em>完整写</em>法是<code>Array&lt;Element&gt;</code>， <code>Element</code>是数组允许存入的值的<strong>类型</strong>。你同样可以<em>简写数组的类型</em>为 <code>[Element]</code>。尽管两种格式功能上相同，我们<strong>更推荐简写</strong>并且涉及到数组类型的时候都会使用<em>简写</em>。</p>
<h4 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> someInts = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()<span class="comment">//完整数组声明</span></div><div class="line"><span class="keyword">var</span> someInts = [<span class="type">Int</span>]() <span class="comment">//简写数组声明</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"someInts is of type[Int] with <span class="subst">\(somInts.<span class="built_in">count</span>)</span> items."</span>)</div><div class="line"><span class="comment">//prints "someInts is of type [Int] with 0 items."</span></div></pre></td></tr></table></figure>
<p>注意 <code>someInts</code>变量的类型通过初始化器的类型推断为 <code>[Int]</code>。</p>
<p><strong>相反</strong>，如果内容<em>已经</em>提供了<em>类型信息</em>， <em>比如说作为函数的实际参数或者已经分类了的变量或常量，你可以通过<strong>空数组字面量来创建一个空数组</strong>，它写作<code>[ ]</code>（一对空方括号）</em> ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">someInts.append(<span class="number">2</span>)</div><div class="line"><span class="comment">//someInts now contains 1 value of type Int</span></div><div class="line">someInts = [] <span class="comment">//数组的字面量复制</span></div><div class="line"><span class="comment">//someInts is now an emtpy array, but is still of type [Int]</span></div></pre></td></tr></table></figure>
<h4 id="使用默认值创建数组"><a href="#使用默认值创建数组" class="headerlink" title="使用默认值创建数组"></a>使用默认值创建数组</h4><p><code>Swift</code> 的 <code>Array</code>类型提供了初始化器来创建确定大小且元素都设定为相同默认值的数组。你可以传给初始化器对应类型的默认值（叫做 <code>repeating</code>）和新数组元素的数量（叫做 <code>count</code>）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> threeDoubles = <span class="type">Array</span>(repeating: <span class="number">0.0</span>, <span class="built_in">count</span>: <span class="number">3</span>)</div><div class="line"><span class="built_in">print</span>(threeDoubles)</div><div class="line"><span class="comment">// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]</span></div></pre></td></tr></table></figure>
<h4 id="通过连接两个数组来创建数组"><a href="#通过连接两个数组来创建数组" class="headerlink" title="通过连接两个数组来创建数组"></a>通过连接两个数组来创建数组</h4><p>你可以通过把<strong>两个兼容类型</strong>的现存数组用加运算符<code>（+）</code>加在一起来创建一个新数组。新数组的类型将从你相加的数组里推断出来：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> anotherThreeDoubles = <span class="type">Array</span>(repeating: <span class="number">2.5</span>, <span class="built_in">count</span>: <span class="number">3</span>)</div><div class="line"><span class="comment">// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> sixDoubles = threeDoubles + anotherThreeDoubles</div><div class="line"><span class="comment">// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span></div></pre></td></tr></table></figure>
<h4 id="使用数组字面量创建数组"><a href="#使用数组字面量创建数组" class="headerlink" title="使用数组字面量创建数组"></a>使用数组字面量创建数组</h4><p>你同样可以使用<em>数组字面量</em>来初始化一个数组，它是一种以数组集合来写一个或者多个值的<em>简写</em>方式。数组字面量写做一系列的值，用逗号分隔，用方括号括起来：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[value <span class="number">1</span>, value <span class="number">2</span>, value <span class="number">3</span>]</div><div class="line"><span class="keyword">var</span> shoppingList: [<span class="type">String</span>] = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</div></pre></td></tr></table></figure>
<p><code>shoppingList</code>变量被声明为“字符串值的数组”写做 <code>[String]</code> 。由于这个特定的数组拥有特定的<code>String</code>值类型，它就只能储存 <code>String</code>值。这里， <code>shoppingList</code>被两个 <code>String</code>值<code>（ &quot;Eggs&quot;和 &quot;Milk&quot;）</code>初始化，写在字符串字面量里。</p>
<p>依托于 <code>Swift</code> 的<em>类型推断</em>，如果你用包含相同类型值的数组<em>字面量</em>初始化数组，就不需要写明数组的类型。<code>shoppingList</code>的初始化可以写得更短：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Egg"</span>, <span class="string">"Milk"</span>]</div></pre></td></tr></table></figure>
<p>因为数组字面量中的值都是相同的类型，Swift 就能够推断 [String]是 shoppingList变量最合适的类型。</p>
<h4 id="访问和修改数组"><a href="#访问和修改数组" class="headerlink" title="访问和修改数组"></a>访问和修改数组</h4><p>你可以通过数组的方法和属性来修改数组，或者使用下标脚本语法。要得出数组中元素的<em>数量</em>，检查只读的 <code>count</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"The shopping list contains <span class="subst">\(shoppingList.<span class="built_in">count</span>)</span> items."</span>)</div><div class="line"><span class="comment">// prints "The shopping list contains 2 items."</span></div></pre></td></tr></table></figure>
<p>使用布尔量 <code>isEmpty</code>属性来作为检查 count属性是否等于 <code>0</code>的快捷方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> shoppingList.isEmpty &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The shopping list is empty."</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The shopping list is not empty."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints "The shopping list is not empty."</span></div></pre></td></tr></table></figure>
<p>你可以通过 <code>append(_:)</code>方法给数组末尾添加新的元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shoppingList.append(<span class="string">"Flour"</span>)</div><div class="line"><span class="comment">// shoppingList now contains 3 items, and someone is making pancakes</span></div></pre></td></tr></table></figure>
<p>另外，可以使用加赋值运算符 <code>(+=)</code>来在数组末尾添加一个或者多个同类型元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">shoppingList += [<span class="string">"Baking Powder"</span>]</div><div class="line"><span class="comment">// shoppingList now contains 4 items</span></div><div class="line">shoppingList += [<span class="string">"Chocolate Spread"</span>, <span class="string">"Cheese"</span>, <span class="string">"Butter"</span>]</div><div class="line"><span class="comment">//// shoppingList now contains 7 items</span></div></pre></td></tr></table></figure>
<p>通过<em>下标脚本语法</em>来从数组当中取回一个值，在紧跟数组名后的方括号内传入你想要取回的值的索引：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fristItem = shoppingList[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<p>你可以使用<em>下标脚本语法</em>来改变给定索引中已经存在的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shoppingList[<span class="number">0</span>] = <span class="string">"Six eggs"</span></div><div class="line"><span class="comment">// the first item in the list is now equal to "Six eggs" rather than "Eggs"</span></div></pre></td></tr></table></figure>
<p>你同样可以使用<em>下标脚本语法</em>来一次改变一个<em>范围</em>的值，就算<em>替换与范围长度不同</em>的值的合集也行。下面的栗子替换用 “Bananas”和 “Apples”替换 “Chocolate Spread”, “Cheese”, and “Butter”：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shoppingList[<span class="number">4</span>...<span class="number">6</span>] = [<span class="string">"Bananas"</span>, <span class="string">"Apples"</span>]</div><div class="line"><span class="comment">// shoppingList now contains 6 items</span></div></pre></td></tr></table></figure>
<p>调用 <code>insert(_:at:)</code>方法<strong>插入</strong>了一个新元素值为 <code>&quot;Maple Syrup&quot;</code>到 <code>shopping list</code> 的最前面，通过明确索引位置为 0 .<br>类似地，你可以使用<code>remove(at:)</code>方法来<strong>移除</strong>一个元素。这个方法移除特定索引的元素并且返回它（尽管你不需要的话可以无视返回的值）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shoppingList.insert(<span class="string">"Maple Syrup"</span>, at: <span class="number">0</span>)</div><div class="line"><span class="keyword">let</span> mapleSyrup = shoppingList.remove(at: <span class="number">0</span>)</div></pre></td></tr></table></figure>
<h4 id="遍历一个数组"><a href="#遍历一个数组" class="headerlink" title="遍历一个数组"></a>遍历一个数组</h4><p>你可以用 <code>for-in</code>循环来遍历整个数组中值的合集</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoppingList &#123;</div><div class="line">    <span class="built_in">print</span>(item)</div><div class="line">&#125;</div><div class="line"><span class="comment">//Six eggs</span></div><div class="line"><span class="comment">//Milk</span></div><div class="line"><span class="comment">//Flour</span></div><div class="line"><span class="comment">//Baking Powder</span></div><div class="line"><span class="comment">//Bananas</span></div><div class="line"><span class="comment">//Apples</span></div></pre></td></tr></table></figure>
<p>如果你需要每个<em>元素以及值的整数索引</em>，使用 <em>enumerated()</em>方法来遍历数组。 <em>enumerated()</em>方法返回数组中每一个<em>元素的元组</em>，包含了这个元素的<strong>索引和值</strong>。你可以分解元组为临时的<em>常量</em>或者<em>变量</em>作为遍历的一部分：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> shoppingList.enumerated() &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Item <span class="subst">\(index + <span class="number">1</span>)</span>: <span class="subst">\(value)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="type">Item</span> <span class="number">2</span>: <span class="type">Milk</span></div><div class="line"><span class="type">Item</span> <span class="number">3</span>: <span class="type">Flour</span></div><div class="line"><span class="type">Item</span> <span class="number">4</span>: <span class="type">Baking</span> <span class="type">Powder</span></div><div class="line"><span class="type">Item</span> <span class="number">5</span>: <span class="type">Bananas</span></div><div class="line"><span class="type">Item</span> <span class="number">6</span>: <span class="type">Apples</span></div></pre></td></tr></table></figure>
<h3 id="合集"><a href="#合集" class="headerlink" title="合集"></a>合集</h3><p><em>合集</em>将同一类型且<strong>不重复的值</strong>、<strong>无序地</strong>储存在一个集合当中。当元素的顺序不那么重要的时候你就可以使用合集来代替数组，或者你需要确保元素不会重复的时候。<br><em>注意：<code>Swift</code> 的 <code>Set</code>类型桥接到了基础框架的 <code>NSSet</code>类上。</em></p>
<h4 id="Set-类型的哈希值"><a href="#Set-类型的哈希值" class="headerlink" title="Set 类型的哈希值"></a>Set 类型的哈希值</h4><p>为了能让类型储存在合集当中，它必须是<strong>可哈希的</strong>——<em>就是说类型必须提供计算它自身哈希值的方法</em>。哈希值是<code>Int</code>值且所有的对比起来相等的对象都相同，比如 <code>a == b</code>，它遵循 <code>a.hashValue == b.hashValue。</code></p>
<p>所有 <code>Swift</code> 的基础类型（比如 <code>String, Int, Double</code>, 和 <code>Bool</code>）<em>默认都是可哈希的</em>，并且可以用于合集或者字典的<strong>键</strong>。<em>没有关联值的</em>枚举成员值（如同枚举当中描述的那样）同样默认可哈希。</p>
<blockquote>
<p>你可以使用你自己自定义的类型作为合集的值类型或者字典的键类型，只要让它们遵循 Swift 基础库的 Hashable协议即可。遵循 Hashable协议的类型必须提供可获取的叫做 hashValue的 Int属性。通过 hashValue属性返回的值不需要在同一个程序的不同的执行当中都相同，或者不同程序。</p>
<p>因为 Hashable协议遵循 Equatable，遵循的类型必须同时一个“等于”运算符 ( ==)的实现。 Equatable协议需要任何遵循 ==的实现都具有等价关系。就是说， ==的实现必须满足以下三个条件，其中 a, b, 和 c是任意值：</p>
<ul>
<li><code>a == a</code>  (自反性)</li>
<li><code>a == b</code> 意味着<code>b == a</code>  (对称性)</li>
<li><code>a == b &amp;&amp; b == c</code> 意味着 <code>a == c</code> (传递性)</li>
</ul>
</blockquote>
<h4 id="合集类型语法"><a href="#合集类型语法" class="headerlink" title="合集类型语法"></a>合集类型语法</h4><p><code>Swift</code> 的合集类型写做 <code>Set&lt;Element&gt;</code>，这里的 <code>Element</code>是合集要储存的类型。不同与数组，合集<em>没有等价的简写</em>。</p>
<h4 id="创建并初始化一个空合集"><a href="#创建并初始化一个空合集" class="headerlink" title="创建并初始化一个空合集"></a>创建并初始化一个空合集</h4><p>你可以使用初始化器语法来创建一个确定类型的空合集：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> letters = <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</div><div class="line"><span class="built_in">print</span>(<span class="string">"letters is of type Set&lt;Character&gt; with <span class="subst">\(letters.<span class="built_in">count</span>)</span> items."</span>)</div><div class="line"><span class="comment">// prints "letters is of type Set&lt;Character&gt; with 0 items."</span></div></pre></td></tr></table></figure>
<p>另外，如果内容已经提供了类型信息，比如函数的实际参数或者已经分类的变量常量，你就可以<strong>用空的数组字面量</strong>来创建一个空合集：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">letters.insert(<span class="string">"a"</span>)</div><div class="line"><span class="comment">// letters now contains 1 value ('a') of type Charactor</span></div><div class="line"><span class="built_in">print</span>(letters)</div><div class="line">letters = []</div><div class="line"><span class="built_in">print</span>(letters)</div><div class="line"><span class="comment">// letters is now an empty set, but is still of type Set&lt;Character&gt;</span></div></pre></td></tr></table></figure>
<h4 id="使用数组字面量创建合集"><a href="#使用数组字面量创建合集" class="headerlink" title="使用数组字面量创建合集"></a>使用数组字面量创建合集</h4><p>你同样可以<em>使用数组字面量</em>来初始化一个合集，算是一种写一个或者多个合集值的快捷方式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"Rock"</span>,  <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</div><div class="line"><span class="comment">// favroiteGenres has been initialized with three initial items</span></div></pre></td></tr></table></figure>
<p><code>favoriteGenres</code>变量被声明为“ <code>String</code>值的合集”，写做 <code>Set&lt;String&gt;</code>。由于这个合集已经被明确值类型为 <code>String</code>，它只允许储存 <code>String</code>值。这时，合集 <code>favoriteGenres</code>用三个写在数组字面量中的 <code>String</code>值 <code>( &quot;Rock&quot;, &quot;Classical&quot;, 和 &quot;Hip hop&quot;)</code>初始化。</p>
<p>由于 <code>Swift</code> 的类型推断，你不需要在使用包含<em>相同类型值的数组字面量初始化合集</em>的时候写合集的<strong>类型</strong>。 <code>favoriteGenres</code> 的初始化可以写的更短一些：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span> = [<span class="string">"Rock"</span>,  <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</div><div class="line"><span class="comment">//Swift 就可以推断 Set&lt;String&gt;是 favoriteGenres变量的正确类型</span></div></pre></td></tr></table></figure>
<h4 id="访问和修改合集"><a href="#访问和修改合集" class="headerlink" title="访问和修改合集"></a>访问和修改合集</h4><p><code>Swift</code>提供一些列API来访问和修改集合：<code>count、isEmpty、insert(_:)、remove(_:)、removeAll()、contains(_:)</code></p>
<h4 id="遍历合集"><a href="#遍历合集" class="headerlink" title="遍历合集"></a>遍历合集</h4><p>你可以在 <code>for-in</code>循环里遍历合集的值。<br><code>Swift</code> 的 <code>Set</code>类型是<strong>无序的</strong>。要以特定的顺序遍历合集的值，使用 <code>sorted()</code>方法，它把合集的元素作为使用 <code>&lt;</code> 运算符排序了的数组返回</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres &#123;</div><div class="line">    <span class="built_in">print</span>(genre)</div><div class="line">&#125;</div><div class="line"><span class="comment">//Hip hop</span></div><div class="line"><span class="comment">//Rock</span></div><div class="line"><span class="comment">//Classical</span></div><div class="line"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres.sorted() &#123;</div><div class="line">    <span class="built_in">print</span>(genre)</div><div class="line">&#125;</div><div class="line"><span class="comment">//Classical</span></div><div class="line"><span class="comment">//Hip hop</span></div><div class="line"><span class="comment">//Rock</span></div></pre></td></tr></table></figure>
<h3 id="执行合集操作"><a href="#执行合集操作" class="headerlink" title="执行合集操作"></a>执行合集操作</h3><p>下边的示例描述了两个合集—— <code>a</code>和 <code>b</code>——在各种合集操作下的结果，用阴影部分表示。<br><img style="margin: .auto" src="/2017/10/30/swift-collection/setVennDiagram_2x(1).png" alt="setVennDiagram_2x (1)" title="集合关系"></p>
<ul>
<li>使用 <code>intersection(_:)</code>方法来创建一个只包含两个合集共有值的新合集；</li>
<li>使用 <code>symmetricDifference(_:)</code>方法来创建一个只包含两个合集各自有的非共有值的新合集；</li>
<li>使用 <code>union(_:)</code>方法来创建一个包含两个合集所有值的新合集；</li>
<li>使用 <code>subtracting(_:)</code>方法来创建一个两个合集当中不包含某个合集值的新合集。</li>
</ul>
<p>下面的示例描述了三个合集—— <code>a</code>， <code>b</code>和 <code>c</code>——用重叠区域代表合集之间值共享。合集 <code>a</code>是合集 <code>b</code>的超集，因为 <code>a</code>包含 <code>b</code>的所有元素。相反地，合集 <code>b</code>是合集 a<code>的</code>子集，因为 <code>b</code>的所有元素被 <code>a</code>包含。合集 <code>b</code>和合集 <code>c</code>是不相交的，因为他们的元素没有相同的。</p>
<p><img style="margin: .auto" src="/2017/10/30/swift-collection/setEulerDiagram_2x(2).png" alt="setEulerDiagram_2x(2)" title="集合关系"></p>
<ul>
<li>使用“相等”运算符 <code>( == )</code>来判断两个合集是否包含有相同的值；</li>
<li>使用 <code>isSubset(of:)</code> 方法来确定一个合集的所有值是被某合集包含；</li>
<li>使用 <code>isSuperset(of:)</code>方法来确定一个合集是否包含某个合集的所有值；</li>
<li>使用 <code>isStrictSubset(of:)</code> 或者 <code>isStrictSuperset(of:)</code>方法来确定是个合集是否为某一个合集的<em>子集或者超集</em>，<strong>但并不相等</strong>；</li>
<li>使用 <code>isDisjoint(with:)</code>方法来判断两个合集是否拥有完全不同的值。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> houseAnimals: <span class="type">Set</span> = [<span class="string">"🐶"</span>, <span class="string">"🐱"</span>]</div><div class="line"><span class="keyword">let</span> farmAnimals: <span class="type">Set</span> = [<span class="string">"🐮"</span>, <span class="string">"🐔"</span>, <span class="string">"🐑"</span>, <span class="string">"🐶"</span>, <span class="string">"🐱"</span>]</div><div class="line"><span class="keyword">let</span> cityAnimals: <span class="type">Set</span> = [<span class="string">"🐦"</span>, <span class="string">"🐭"</span>]</div><div class="line"><span class="built_in">print</span>(houseAnimals.isSubset(of: farmAnimals))   <span class="comment">//true</span></div><div class="line"><span class="built_in">print</span>(farmAnimals.isSuperset(of: houseAnimals)) <span class="comment">//true</span></div><div class="line"><span class="built_in">print</span>(farmAnimals.isDisjoint(with: cityAnimals))<span class="comment">//true</span></div></pre></td></tr></table></figure>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p><strong>字典</strong>储存无序的互相关联的同一类型的<em>键</em>和同一类型的<em>值</em>的集合。每一个值都与唯一的键相关联，它就好像这个值的身份标记一样。不同于数组中的元素，字典中的元素没有特定的顺序。当你需要查找基于特定标记的值的时候使用字典，很类似现实生活中字典用来查找特定字的定义。</p>
<h4 id="字典类型简写语法"><a href="#字典类型简写语法" class="headerlink" title="字典类型简写语法"></a>字典类型简写语法</h4><p><code>Swift</code> 的字典类型写全了是这样的： <code>Dictionary&lt;Key, Value&gt;</code>，其中的 <code>Key</code>是用来作为字典键的值类型， <code>Value</code>就是字典为这些键储存的值的类型。</p>
<blockquote>
<p>字典的 <code>Key</code>类型必须遵循 <code>Hashable</code>协议，就像合集的值类型</p>
</blockquote>
<p>简写形式：<code>[Key: Value]</code></p>
<h4 id="创建一个空字典"><a href="#创建一个空字典" class="headerlink" title="创建一个空字典"></a>创建一个空字典</h4><p>就像数组，你可以用初始化器语法来创建一个空 <code>Dictionary</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nameOfIntegers = [<span class="type">Int</span>: <span class="type">String</span>]()</div></pre></td></tr></table></figure>
<p>如果内容已经提供了信息，你就可以用字典字面量创建空字典了，它写做 [:]（在一对方括号里写一个冒号）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nameOfIntegers[<span class="number">16</span>] = <span class="string">"sixteen"</span></div><div class="line"><span class="comment">// namesOfIntegers now contains 1 key-value pair</span></div><div class="line">nameOfIntegers = [:]</div><div class="line"><span class="comment">// namesOfIntegers is once again an empty dictionary of type [Int: String]</span></div></pre></td></tr></table></figure>
<h4 id="用字典字面量创建字典"><a href="#用字典字面量创建字典" class="headerlink" title="用字典字面量创建字典"></a>用字典字面量创建字典</h4><p>你同样可以使用字典字面量来初始化一个字典，它与数组字面量看起来差不多。字典字面量是写一个或者多个键值对为 <code>Dictionary</code>集合的快捷方式。</p>
<p>键值对由一个键和一个值组合而成，每个键值对里的键和值用冒号分隔。键值对写做一个列表，用逗号分隔，并且最终用方括号把它们括起来：</p>
<p><code>[key 1: value 1, key 2: value 2, key 3: value 3]</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//airports字典被声明为 [String: String]类型，它意思是“一个键和值都是 String的 Dictionary”。</span></div><div class="line"><span class="keyword">var</span> airports: [<span class="type">String</span>: <span class="type">String</span>] = [<span class="string">"YYZ"</span>: <span class="string">"Toronto Pearson"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]</div></pre></td></tr></table></figure>
<p>与数组一样，如果你用<em>一致类型的字典字面量初始化字典</em>，就不需要写出字典的类型了。 <code>airports</code>的初始化就能写的更短：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//由于字面量中所有的键都有相同的类型，同时所有的值也是相同的类型，</span></div><div class="line"><span class="comment">//Swift 可以推断 [String: String]就是 airports字典的正确类型。</span></div><div class="line"><span class="keyword">var</span> airports = [<span class="string">"YYZ"</span>: <span class="string">"Toronto Pearson"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]</div></pre></td></tr></table></figure>
<h4 id="访问和修改字典"><a href="#访问和修改字典" class="headerlink" title="访问和修改字典"></a>访问和修改字典</h4><p>你可以通过字典自身的方法和属性来访问和修改它，或者通过使用下标脚本语法。</p>
<p>如同数组:</p>
<ul>
<li>你可以使用 <code>count</code>只读属性来找出 Dictionary拥有多少元素</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"The airports dictionary contains <span class="subst">\(airports.<span class="built_in">count</span>)</span> items."</span>)</div></pre></td></tr></table></figure>
<ul>
<li>用布尔量 <code>isEmpty</code>属性作为检查 <code>count</code>属性是否等于 <code>0</code>的快捷方式</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> airports.isEmpty &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary is empty."</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary is not empty."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints "The airports dictionary is not empty."</span></div></pre></td></tr></table></figure>
<ul>
<li>你可以用下标脚本给字典添加新元素。使用正确类型的新键作为下标脚本的索引，然后赋值一个正确类型的值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">airports[<span class="string">"LHR"</span>] = <span class="string">"London"</span></div><div class="line"><span class="comment">// the airports dictionary now contains 3 items</span></div></pre></td></tr></table></figure>
<ul>
<li>你同样可以使用下标脚本语法来改变特定键关联的值：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">airports[<span class="string">"LHR"</span>] = <span class="string">"London Heathrow"</span></div><div class="line"><span class="comment">// the value for "LHR" has been changed to "London Heathrow"</span></div></pre></td></tr></table></figure>
<ul>
<li><code>updateValue(_:forKey:)</code>。不同于下标脚本， <code>updateValue(_:forKey:)</code>方法在执行更新之后返回旧的值。这允许你检查更新是否成功。</li>
</ul>
<p><code>updateValue(_:forKey:)</code>方法返回一个字典值类型的可选项值。比如对于储存 <code>String</code>值的字典来说，方法会返回 <code>String?</code>类型的值，或者说“可选的 <code>String</code>”。这个可选项包含了键的旧值如果更新前存在的话，否则就是 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> oldValue = airports.updateValue(<span class="string">"Dublin Airport"</span>, forKey: <span class="string">"DUB"</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The old value for DUB was <span class="subst">\(oldValue)</span>."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints "The old value for DUB was Dublin."</span></div></pre></td></tr></table></figure>
<ul>
<li>你可以使用下标脚本语法给一个键赋值 <code>nil</code>来从字典当中移除一个键值对：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">airports[<span class="string">"APL"</span>] = <span class="string">"Apple International"</span></div><div class="line"><span class="comment">// "Apple International" is not the real airport for APL, so delete it</span></div><div class="line">airports[<span class="string">"APL"</span>] = <span class="literal">nil</span></div><div class="line"><span class="comment">// APL has now been removed from the dictionary</span></div></pre></td></tr></table></figure>
<ul>
<li>另外，使用 <code>removeValue(forKey:)</code>来从字典里移除键值对。这个方法移除键值对如果他们存在的话，并且返回移除的值，如果值不存在则返回 <code>nil</code>：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedValue = airports.removeValue(forKey: <span class="string">"DUB"</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The removed airport's name is <span class="subst">\(removedValue)</span>."</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary does not contain a value for DUB."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Prints "The removed airport's name is Dublin Airport."</span></div></pre></td></tr></table></figure>
<h4 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h4><p>你可以用 <code>for-in</code>循环来遍历字典的键值对。字典中的每一个元素返回为<code>(key, value)</code>元组，你可以解开元组成员到临时的常量或者变量作为遍历的一部分：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (airportCode, airportName) <span class="keyword">in</span> airports &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(airportCode)</span>: <span class="subst">\(airportName)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// YYZ: Toronto Pearson</span></div><div class="line"><span class="comment">// LHR: London Heathrow</span></div></pre></td></tr></table></figure>
<p>你同样可以通过访问字典的 <code>keys</code>和 <code>values</code>属性来取回可遍历的字典的键或值的集合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> airportCode <span class="keyword">in</span> airports.keys &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Airport code: <span class="subst">\(airportCode)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Airport code: YYZ</span></div><div class="line"><span class="comment">// Airport code: LHR</span></div><div class="line"> </div><div class="line"><span class="keyword">for</span> airportName <span class="keyword">in</span> airports.values &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Airport name: <span class="subst">\(airportName)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Airport name: Toronto Pearson</span></div><div class="line"><span class="comment">// Airport name: London Heathrow</span></div></pre></td></tr></table></figure>
<p>如果你需要和接收 <code>Array</code>实例的 <code>API</code> 一起使用字典的键或值，就用 <code>keys</code>或 <code>values</code>属性来初始化一个新数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> airportCodes = [<span class="type">String</span>](airports.keys)</div><div class="line"><span class="comment">// airportCodes is ["YYZ", "LHR"]</span></div><div class="line"><span class="keyword">let</span> airportNames = [<span class="type">String</span>](airports.values)</div><div class="line"><span class="comment">// airportNames is ["Toronto Pearson", "London Heathrow"]</span></div></pre></td></tr></table></figure>
<p><code>Swift</code> 的 <code>Dictionary</code>类型是无序的。要以特定的顺序遍历字典的键或值，使用键或值的 <code>sorted()</code>方法。</p>
<blockquote>
<p>摘自：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" target="_blank" rel="external">swift 官网</a><br>所有代码在Xcode9 Swift4 环境编译没问题，代码<a href="https://github.com/keshiim/LearnSwift4" target="_blank" rel="external">戳这里 https://github.com/keshiim/LearnSwift4</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keshiim.github.io/2017/10/27/swift-stringAndCharacter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng keshiim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Farmer, keshiim 播种太阳🌞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/27/swift-stringAndCharacter/" itemprop="url">Swift：字符串和字符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-27T16:49:36+08:00">
                2017-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/27/swift-stringAndCharacter/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/27/swift-stringAndCharacter/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/10/27/swift-stringAndCharacter/" class="leancloud_visitors" data-flag-title="Swift：字符串和字符">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>字符串</em>是一系列的字符，比如说 <code>&quot;hello, world&quot;</code>或者 <code>&quot;albatross&quot;</code>。<code>Swift</code> 的字符串用 <code>String</code>类型来表示。 <code>String</code>的内容可以通过各种方法来访问到，包括作为 <code>Character</code>值的集合。</p>
<p><code>Swift</code> 的 <code>String</code>  和 <code>Character</code>  类型提供了<em>一种快速的符合</em> <code>Unicode</code> 的方式操作你的代码。字符串的创建和修改语法非常轻量易读，使用与 <code>C</code> 类似的字符串字面量语法。字符串串联只需要使用 <code>+</code>运算符即可，字符串的可修改能力通过选择常量和变量来进行管理，就如同 <code>Swift</code> 语言中的其他值。你同样可以使用字符串来 <em><em>插入</em>常量、变量、字面量以及表达式到更长的字符串当中</em> ，这就是所谓的<em>字符串插值</em>。这样让创建自定义字符串值来显示、储存和打印值变得更加简单。</p>
<p>别看语法简单，<code>Swift</code> 的 <code>String</code>类型仍旧是快速和现代的字符串实现。每一个字符串都是由 <code>Unicode</code> 字符的<em>独立编码组成</em>，并且提供了多种 <code>Unicode</code> 表示下访问这些字符的支持。</p>
<blockquote>
<p><code>Swift</code> 的 <code>String</code>类型桥接到了基础库中的 <code>NSString</code>类。<code>Foundation</code> 同时也扩展了所有 <code>NSString</code> 定义的方法给 <code>String</code> 。也就是说，如果你导入 <code>Foundation</code> ，就可以在 <code>String</code> 中访问所有的 <code>NSString</code>  方法，无需转换格式。</p>
</blockquote>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>你可以在你的代码中插入预先写好的 <code>String</code>值作为字符串<code>字面量</code>。字符串字面量是被双引号包裹的固定顺序文本字符（ “）。<br>使用字符串字面量作为常量或者变量的初始值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> someString = <span class="string">"Some string literal value."</span></div></pre></td></tr></table></figure>
<p>注意 <code>Swift</code> 会为 <code>someString</code>常量推断类型为 <code>String</code>，因为你用了字符串字面量值来初始化。</p>
<p>如果你需要很多行的字符串，使用多行字符串字面量。多行字符串字面量是用三个双引号引起来的一系列字符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> quotation = <span class="string">""</span><span class="string">"</span></div><div class="line"><span class="string">The white rabbit put on his spectacles.  "</span><span class="keyword">where</span> shall <span class="type">I</span> begin.</div><div class="line">please your <span class="type">Majesty</span>?<span class="string">" he asked.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">"</span><span class="type">Begin</span> at the beginning,<span class="string">" the King said gravely, and go on</span></div><div class="line"><span class="string">till you come to the end; then stop."</span></div><div class="line"><span class="string">""</span><span class="string">"</span></div><div class="line"><span class="string">print(quotation)</span></div></pre></td></tr></table></figure>
<p>如同上面展示的那样，由于多行用了三个双引号而不是一个，你可以在多行字面量中使用单个双引号 “ 。要在多行字符串中包含 <code>&quot;&quot;&quot;</code> ，你必须用反斜杠<code>（ \ ）</code>转义至少其中一个双引号。举例来说：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> threeDoubleQuotes = <span class="string">""</span><span class="string">"</span></div><div class="line"><span class="string">Escaping the first quote \""</span><span class="string">"</span></div><div class="line"><span class="string">Escaping all three quote \"\"\"</span></div><div class="line"><span class="string">"</span><span class="string">""</span></div><div class="line"><span class="built_in">print</span>(threeDoubleQuotes)</div></pre></td></tr></table></figure>
<p>在这个多行格式中，字符串字面量包含了双引号包括的所有行。字符串起始于三个双引号<code>（ &quot;&quot;&quot; ）</code>之后的第一行，结束于三个双引号<code>（ &quot;&quot;&quot; ）</code>之前的一行，也就是说<strong>双引号</strong>不会开始或结束带有<strong>换行</strong>。下面的两个字符串是一样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> singleLineString = <span class="string">"These are the same"</span></div><div class="line"><span class="keyword">let</span> multilineString = <span class="string">""</span><span class="string">"</span></div><div class="line"><span class="string">There are the same</span></div><div class="line"><span class="string">"</span><span class="string">""</span></div></pre></td></tr></table></figure>
<p>要让多行字符串字面量开始或结束带有换行，写一个空行作为第一行或者是最后一行。比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">""</span><span class="string">"</span></div><div class="line"><span class="string"> </span></div><div class="line"><span class="string">This string starts with a line feed.</span></div><div class="line"><span class="string">It also ends with a line feed.</span></div><div class="line"><span class="string"> </span></div><div class="line"><span class="string">"</span><span class="string">""</span></div></pre></td></tr></table></figure>
<p>行字符串可以缩进以匹配周围的代码。双引号<code>（ &quot;&quot;&quot; ）</code>前的空格会告诉 <code>Swift</code> 其他行前应该有多少空白是需要忽略的。比如说，尽管下面函数中多行字符串字面量<strong>缩进</strong>了，但实际上字符串不会以任何空白开头。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateQuotation</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">let</span> quotation = <span class="string">""</span><span class="string">"</span></div><div class="line"><span class="string">        The white rabbit put on his spectacles.  "</span><span class="keyword">where</span> shall <span class="type">I</span> begin.</div><div class="line">        please your <span class="type">Majesty</span>?<span class="string">" he asked.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        "</span><span class="type">Begin</span> at the beginning,<span class="string">" the King said gravely, and go on</span></div><div class="line"><span class="string">        till you come to the end; then stop."</span></div><div class="line">        <span class="string">""</span><span class="string">"</span></div><div class="line"><span class="string">    return quotation</span></div><div class="line"><span class="string">&#125;</span></div><div class="line"><span class="string">print(generateQuotation())</span></div><div class="line"><span class="string">print(quotation == generateQuotation()) //true</span></div></pre></td></tr></table></figure>
<p>总而言之，如果你在某行的空格超过了<strong>结束</strong>的<em>双引号</em><code>（ &quot;&quot;&quot; ）</code>，那么这些空格会被包含。也就是说以结束的<code>&quot;&quot;&quot;</code>左右标尺衡量。如图：<br><img style="margin: auto;" src="/2017/10/27/swift-stringAndCharacter/multilineStringWhitespace.png" alt="多行尾双引号为准" title="多行尾双引号为准"></p>
<h3 id="初始化一个空字符串"><a href="#初始化一个空字符串" class="headerlink" title="初始化一个空字符串"></a>初始化一个空字符串</h3><p>为了绑定一个更长的字符串，要在一开始创建一个空的 <code>String</code>值，要么赋值一个空的字符串字面量给变量，要么使用初始化器语法来初始化一个新的 <code>String</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> emptyString = <span class="string">""</span></div><div class="line"><span class="keyword">var</span> anotherEmptyString = <span class="type">String</span>()</div></pre></td></tr></table></figure>
<p>通过检查布尔量 isEmpty属性来确认一个 String值是否为空：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Nothing to see here"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串可变性"><a href="#字符串可变性" class="headerlink" title="字符串可变性"></a>字符串可变性</h3><p>你可以通过把一个 <code>String</code>设置为<strong>变量</strong>（<em>这里指可被修改</em>），或者为<strong>常量</strong>（<em>不能被修改</em>）来指定它是否可以被修改（或者改变）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> variableString = <span class="string">"Horse"</span></div><div class="line">variableString += <span class="string">" and carriage"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> constantString = <span class="string">"Highlander"</span></div><div class="line">constantString += <span class="string">"and another Highlander"</span> <span class="comment">//compile-time error</span></div></pre></td></tr></table></figure>
<h3 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h3><p><code>Swift</code> 的 <code>String</code>类型是一种值类型。如果你创建了一个新的 <code>String</code>值， <code>String</code>值在传递给方法或者函数的时候会被<strong>复制</strong>过去，还有赋值给常量或者变量的时候也是一样。每一次赋值和传递，现存的 <code>String</code>值都会被复制一次，传递走的是<strong>拷贝</strong>而不是原本。</p>
<p><code>Swift</code> 的默认拷贝 <code>String</code>行为保证了当一个方法或者函数传给你一个 <code>String</code>值，你就绝对拥有了这个 <code>String</code>值， <em>无需关心它从哪里来。</em> 你可以确定你传走的这个字符串除了你自己就不会有别<em>人改变它</em>。</p>
<h3 id="操作字符"><a href="#操作字符" class="headerlink" title="操作字符"></a>操作字符</h3><p>你可以通过在 <code>for-in</code>循环里遍历 <code>characters</code>属性访问 <code>String</code> 中的每一个独立的 <code>Character</code>值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"Dog!🐶"</span>.characters &#123;</div><div class="line">    <span class="built_in">print</span>(character)</div><div class="line">&#125;</div><div class="line"><span class="comment">// D</span></div><div class="line"><span class="comment">// o</span></div><div class="line"><span class="comment">// g</span></div><div class="line"><span class="comment">// !</span></div><div class="line"><span class="comment">// 🐶</span></div></pre></td></tr></table></figure>
<p>另外，你可以通过提供 <code>Character</code>类型标注来从<strong>单个字符</strong>的字符串字面量创建一个独立的 <code>Character</code>常量或者变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> = <span class="string">"!"</span></div></pre></td></tr></table></figure>
<p><code>String</code>值可以通过传入 <code>Character</code>值的字符串作为实际参数到它的初始化器来构造：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> catCharacters: [<span class="type">Character</span>] = [<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"t"</span>, <span class="string">"!"</span>, <span class="string">"🐱"</span>]</div><div class="line"><span class="keyword">let</span> catString = <span class="type">String</span>(catCharacters)</div><div class="line"><span class="built_in">print</span>(catString);</div><div class="line"><span class="comment">//print "cat!🐱"</span></div></pre></td></tr></table></figure>
<h3 id="连接字符串和字符"><a href="#连接字符串和字符" class="headerlink" title="连接字符串和字符"></a>连接字符串和字符</h3><p><code>String</code>值能够被加起来（或者说连接），使用加运算符<code>（+）</code>来创建新的<code>String</code>值，你同样也可以使用加赋值符号<code>（+=）</code>在已经存在的 <code>String</code>值末尾追加一个 <code>String</code>值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> string1 = <span class="string">"hello"</span></div><div class="line"><span class="keyword">let</span> string2 = <span class="string">" there"</span></div><div class="line"><span class="keyword">var</span> welcome = string1 + string2 <span class="comment">// welcome now equals "hello there"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instruction = <span class="string">"look over"</span></div><div class="line">instruction += string2 <span class="comment">// instruction now equals "look over there"</span></div></pre></td></tr></table></figure>
<p>你使用 <code>String</code>类型的 <code>append()</code>方法来可以给一个 <code>String</code>变量的末尾追加 <code>Character</code>值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> = <span class="string">"!"</span></div><div class="line">welcome.append(exclamationMark)</div></pre></td></tr></table></figure>
<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p><em>字符串插值</em>是一种从混合<strong>常量、变量、字面量和表达式的字符串字面量</strong>构造新 <code>String</code>值的方法。每一个你插入到字符串字面量的元素都要被一对圆括号包裹，然后使用<em>反斜杠前缀</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> multiplier = <span class="number">3</span></div><div class="line"><span class="keyword">let</span> message = <span class="string">"<span class="subst">\(multiplier)</span> times 2.5 is <span class="subst">\(Double(multiplier)</span>) * 2.5"</span></div><div class="line"><span class="comment">// message is "3 times 2.5 is 7.5"</span></div></pre></td></tr></table></figure>
<p>在上边的栗子当中， <code>multiplier</code>的值以 <code>\(multiplier)</code>的形式插入到了字符串字面量当中。当字符串插值需要被用来创建真的字符串的时候，这个占位符就会被 <code>multiplier</code>的<strong>真实</strong>值代替。</p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p><code>Unicode</code> 是一种在不同书写系统中编码、表示和处理文本的国际标准。它允许你表示几乎标准化格式的任何语言中的任何字符，并且为外部源比如文本文档或者网页读写这些字符。如同这节中描述的那样，<code>Swift</code> 的 <code>String</code>和 <code>Character</code>类型是完全 <em>Unicode</em> 兼容的。</p>
<h4 id="Unicode-标量"><a href="#Unicode-标量" class="headerlink" title="Unicode 标量"></a>Unicode 标量</h4><p>面板之下，<code>Swift</code> 的原生 <code>String</code> 类型建立于 <em>Unicode</em> 标量值之上。一个 <em>Unicode</em> 标量是一个为字符或者修饰符创建的独一无二的<strong>21位数字，</strong>比如 <code>LATIN SMALL LETTER A (&quot; a&quot;)</code>的 <code>U+0061</code> ，或者<code>FRONT-FACING BABY CHICK  ( &quot;🐥&quot; )</code>的 <code>U+1F425</code> 。</p>
<blockquote>
<p><em>Unicode</em> 标量码位位于 <code>U+0000</code>到 <code>U+D7FF</code>或者 <code>U+E000</code>到 <code>U+10FFFF</code>之间。<em>Unicode</em> 标量码位不包括从 <code>U+D800</code>到 <code>U+DFFF</code>的<strong>16</strong>位码元码位。</p>
</blockquote>
<h4 id="字符串字面量中的特殊字符"><a href="#字符串字面量中的特殊字符" class="headerlink" title="字符串字面量中的特殊字符"></a>字符串字面量中的特殊字符</h4><p>字符串字面量能包含以下特殊字符：</p>
<ul>
<li>转义特殊字符 <code>\0 (空字符)</code>， <code>\\ (反斜杠)</code>， <code>\t (水平制表符)</code>， <code>\n (换行符)</code>， <code>\r(回车符)</code>，<code>\&quot; (双引号)</code> 以及 <code>\&#39; (单引号)</code>；</li>
<li>任意的 <em>Unicode</em> 标量，写作 <code>\u{n}</code>，里边的 n是一个 <code>1-8</code> 个与合法 <em>Unicode</em> 码位相等的<em>16</em>进制数字。</li>
</ul>
<p>下边的代码展示了这些特殊字符的四个栗子。 <code>wiseWords</code>常量包含了两个转义双引号字符。 <code>dollarSign</code>， <code>blackHeart</code>和 <code>sparklingHeart</code>常量展示了 <em>Unicode</em> 标量格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> wiseWords = <span class="string">"\"Imagination is more improtant than knowledge\" - Einstein"</span></div><div class="line"><span class="comment">// "Imagination is more important than knowledge" - Einstein</span></div><div class="line"><span class="keyword">let</span> dollarSign = <span class="string">"\u&#123;24&#125;"</span> <span class="comment">// $, Unicode scalar U+0024</span></div><div class="line"><span class="keyword">let</span> blackHeart = <span class="string">"\u&#123;2665&#125;"</span> <span class="comment">// ♥, Unicode scalar U+2665</span></div><div class="line"><span class="keyword">let</span> sparklingHeart = <span class="string">"\u&#123;1F496&#125;"</span> <span class="comment">// 💖, Unicode scalar U+1F496</span></div></pre></td></tr></table></figure>
<h4 id="扩展字形集群"><a href="#扩展字形集群" class="headerlink" title="扩展字形集群"></a>扩展字形集群</h4><p>每一个 <code>Swift</code>的 <code>Character</code>类型实例都表示了单一的<em>扩展字形集群</em>。扩展字形集群是一个或者多个有序的 <strong>Unicode</strong> 标量（当组合起来时）产生的单个人类可读字符。<br>举个栗子。字母 <code>é</code>以单个 <strong>Unicode</strong> 标量 <code>é</code> <code>( LATIN SMALL LETTER E WITH ACUTE</code>, 或者 <code>U+00E9</code>)表示。总之，同样的字母<strong>也可以用一对标量</strong>——一个标准的字母 <code>e`` ( LATIN SMALL LETTER E</code>，或者说<code>U+0065</code>)，以及 <code>COMBINING ACUTE ACCENT</code>标量<code>( U+0301)</code>表示。 <code>COMBINING ACUTE ACCENT</code>标量会以<em>图形方式应用</em>到它前边的<strong>标量</strong>上，当 <strong>Unicode</strong> 文本渲染系统渲染时，就会把 <code>e</code>转换为 <code>é</code>来输出。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> eAcute: <span class="type">Character</span> = <span class="string">"\u&#123;e9&#125;"</span> <span class="comment">// é</span></div><div class="line"><span class="keyword">let</span> combinedEAcute: <span class="type">Character</span> = <span class="string">"\u&#123;65&#125;\u&#123;301&#125;"</span></div><div class="line"><span class="comment">// eAcute is é, combinedEAcute is é</span></div></pre></td></tr></table></figure>
<p>扩展字形集群是一种非常灵活的把各种复杂脚本字符作为单一 <code>Character</code>值来表示的方法。比如说韩文字母中的音节能被表示为<strong>复合和分解</strong>序列两种。这两种表示在 <code>Swift</code> 中都<strong>完全合格于单一</strong> <code>Character</code>值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> precomposed: <span class="type">Character</span> = <span class="string">"\u&#123;d55c&#125;"</span> <span class="comment">//한</span></div><div class="line"><span class="keyword">let</span> decomposeed: <span class="type">Character</span> = <span class="string">"\u&#123;1112&#125;\u&#123;1161&#125;\u&#123;11ab&#125;"</span> <span class="comment">// ᄒ, ᅡ, ᆫ</span></div><div class="line"><span class="comment">// precomposed is 한, decomposed is 한</span></div></pre></td></tr></table></figure>
<p>扩展字形集群允许<strong>封闭标记</strong>的标量 (比如 <code>COMBINING ENCLOSING CIRCLE</code>, 或者说 <code>U+20DD</code>) 作为单一 <code>Character</code>值来圈住其他 <code>Unicode</code> 标量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> enclosedEAcute: <span class="type">Character</span> = <span class="string">"\u&#123;E9&#125;\u&#123;20DD&#125;"</span><span class="comment">// enclosedEAcute is é⃝</span></div></pre></td></tr></table></figure>
<p>区域指示符号的 <code>Unicode</code> 标量可以成对组合来成为单一的 <code>Character</code>值，比如说这个 <code>REGIONAL INDICATOR SYMBOL LETTER</code> <strong>U ( U+1F1FA)</strong>和 <code>REGIONAL INDICATOR SYMBOL LETTER</code> <strong>S  ( U+1F1F8)</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> regionalIndicatorForUS: <span class="type">Character</span> = <span class="string">"\u&#123;1f1fa&#125;\u&#123;1f1f8&#125;"</span> <span class="comment">// regionalIndicatorForUS is 🇺🇸</span></div></pre></td></tr></table></figure>
<h3 id="字符统计"><a href="#字符统计" class="headerlink" title="字符统计"></a>字符统计</h3><p>要在字符串中取回 <code>Character</code>值的总数，使用字符串 <code>characters</code>属性中的的 <code>count</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> unusualMenagerie = <span class="string">"Koala🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"unusualMenagerie has <span class="subst">\(unusualMenagerie.characters.<span class="built_in">count</span>)</span> characters"</span>) </div><div class="line"><span class="comment">// prints "unusualMenagerie has 40 characters"</span></div></pre></td></tr></table></figure>
<p>注意 <code>Swift</code> 为 <code>Character</code>值使用的<strong>扩展字形集群*</strong>意味着字符串的创建和修改可能不会总是影响字符串的字符统计数<em>。<br>比如说，如果你使用四个字符的<code>cafe</code>来初始化一个新的字符串，然后追加一个 C</em>OMBINING ACUTE ACCENT*  <code>( U+0301)</code>到字符串的末尾，字符串的字符统计结果将仍旧是<code>4</code>，但第四个字符是<code>é</code>而不是 <code>e</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> word = <span class="string">"cafe"</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.characters.<span class="built_in">count</span>)</span>"</span>)</div><div class="line"><span class="comment">//prints "the number of characters in cafe is 4"</span></div><div class="line">word += <span class="string">"\u&#123;301&#125;"</span> <span class="comment">// COMBINING ACUTE ACCENT, U+301</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.characters.<span class="built_in">count</span>)</span>"</span>)</div><div class="line"><span class="comment">//prints "the number of characters in café is 4"</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<blockquote>
<p>扩展字形集群能够组合一个或者多个 <code>Unicode</code> 标量。这意味着不同的字符——以及相同字符的不同表示——能够获得不同大小的内存来储存。因此，<code>Swift</code> 中的字符并不会在字符串中获得相同的内存空间。所以说，字符串中字符的数量如果不遍历它的扩展字形集群边界的话，是不能被计算出来的。如果你在操作特殊的长字符串值，要注意 <code>characters</code>属性为了确定字符串中的字符要遍历整个字符串的 <code>Unicode</code> 标量。</p>
<p>通过 <code>characters</code>属性返回的字符统计并不会总是与包含相同字符的 <code>NSString</code>中 <code>length</code>属性相同。 <code>NSString</code>中的长度是基于在字符串的 <code>UTF-16</code> 表示中16位码元的数量来表示的，而不是字符串中 <code>Unicode</code> 扩展字形集群的数量。</p>
</blockquote>
<h3 id="访问和修改字符串"><a href="#访问和修改字符串" class="headerlink" title="访问和修改字符串"></a>访问和修改字符串</h3><p>你可以通过下标脚本语法或者它自身的属性和方法来访问和修改字符串。</p>
<h4 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h4><p>每一个 <code>String</code>值都有相关的索引类型， <code>String.Index</code>，它相当于每个 <code>Character</code>在字符串中的位置。</p>
<p>如上文中提到的那样，不同的字符会获得不同的内存空间来储存，所以为了明确哪个 <code>Character</code> 在哪个特定的位置，你必须从 <code>String</code>的开头或结尾遍历每一个 <code>Unicode</code> 标量。因此，<code>Swift</code> 的字符串不能通过整数值索引。</p>
<p>使用 <code>startIndex</code>属性来访问 <code>String</code>中第一个 <code>Character</code>的位置。 <code>endIndex</code>属性就是 <code>String</code>中最后一个字符后的位置。所以说， <code>endIndex</code>属性并不是字符串下标脚本的合法实际参数。如果 <code>String</code>为空，则 <code>startIndex</code>与 <code>endIndex</code>相等。</p>
<p>使用 <code>index(before:)</code> 和 <code>index(after:)</code> 方法来访问给定索引的前后。要访问给定索引更远的索引，你可以使用 <code>index(_:offsetBy:)</code>方法而不是多次调用这两个方法。</p>
<p>你可以使用下标脚本语法来访问 <code>String</code>索引中的特定 <code>Character</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> greeting = <span class="string">"Guten Tag!"</span></div><div class="line">greeting[greeting.startIndex]</div><div class="line"><span class="comment">// G</span></div><div class="line">greeting[greeting.index(before: greeting.endIndex)]</div><div class="line"><span class="comment">// !</span></div><div class="line">greeting[greeting.index(after: greeting.startIndex)]</div><div class="line"><span class="comment">// u</span></div><div class="line"><span class="keyword">let</span> index = greeting.index(greeting.startIndex, offsetBy: <span class="number">7</span>)</div><div class="line">greeting[index]</div><div class="line"><span class="comment">// a</span></div></pre></td></tr></table></figure>
<p>尝试访问的 <code>Character</code>如果索引位置在字符串范围之外，就会触发运行时错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">greeting[greeting.endIndex] <span class="comment">//运行时报错</span></div><div class="line">greeting.index(after: greeting.endIndex) <span class="comment">//运行时报错</span></div></pre></td></tr></table></figure>
<p>使用 <code>characters</code>属性的 <code>indices</code>属性来创建所有能够用来访问字符串中独立字符的索引范围 <code>Range</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.characters.<span class="built_in">indices</span> &#123;</div><div class="line"><span class="comment">//    print("\(greeting[index])")</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(greeting[index])</span>"</span>, terminator: <span class="string">" "</span>) <span class="comment">//G u t e n   T a g !</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<blockquote>
<p>你可以在任何遵循了 <code>Indexable</code> 协议的类型中使用 <code>startIndex</code> 和 <code>endIndex</code> 属性以及 <code>index(before:) ， index(after:)</code>和 <code>index(_:offsetBy:)</code>方法。这包括这里使用的 <code>String</code> ，还有集合类型比如 <code>Array</code> ， <code>Dictionary</code> 和 <code>Set</code>。</p>
</blockquote>
<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>要给字符串的特定索引位置插入字符，使用 <code>insert(_:at:)</code>方法，另外要冲入另一个<strong>字符串</strong>的内容到特定的索引，使用 <code>insert(contentsOf:at:)</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wellcome = <span class="string">"hello"</span></div><div class="line">wellcome.insert(<span class="string">"!"</span>, at: wellcome.endIndex) <span class="comment">//"hello!"</span></div><div class="line">wellcome.insert(contentsOf: <span class="string">" there"</span>.characters, at: wellcome.index(before: wellcome.endIndex)) </div><div class="line"><span class="comment">//"hello there!"</span></div></pre></td></tr></table></figure>
<p>要从字符串的特定索引位置<strong>移除字符</strong>，使用 <code>remove(at:)</code>方法，另外要移除一小段特定范围的<strong>字符串</strong>，使用 <code>removeSubrange(_:)</code> 方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wellcome.remove(at: wellcome.index(before: wellcome.endIndex)) <span class="comment">//"hello there"</span></div><div class="line">wellcome.removeSubrange(wellcome.index(wellcome.endIndex, offsetBy: -<span class="number">6</span>)..&lt;wellcome.endIndex) <span class="comment">//"hello"</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<blockquote>
<p>你可以在任何遵循了 RangeReplaceableIndexable 协议的类型中使用 insert(_:at:) ， insert(contentsOf:at:) ， remove(at:) 方法。这包括了这里使用的 String ，同样还有集合类型比如 Array ， Dictionary 和 Set 。</p>
</blockquote>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p><code>Swift</code> 提供了<em>三</em>种方法来比较文本值：<em>字符串</em>和<em>字符相等性</em>，<em>前缀相等性以及后缀相等性</em>。</p>
<h4 id="字符串和字符相等性"><a href="#字符串和字符相等性" class="headerlink" title="字符串和字符相等性"></a>字符串和字符相等性</h4><p>如同比较运算符中所描述的那样，<strong>字符串和字符</strong>相等使用“<em>等于</em>”运算符<code>( ==)</code> 和“<em>不等</em>”运算符 <code>( !=)</code>进行检查：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> quotation1 = <span class="string">"We`re a lot alike, you and I."</span></div><div class="line"><span class="keyword">let</span> sameQuotation = <span class="string">"We`re a lot alike, you and I."</span></div><div class="line"><span class="keyword">if</span> quotation1 == sameQuotation &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"These two strings are considered equal"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个 <code>String</code>值（或者两个 <code>Character</code>值）如果它们的扩展字形集群是<strong>规范化相等</strong>，则被认为是<em>相等</em>的。如果扩展字形集群拥有相同的<strong>语言意义和外形</strong>，我们就说它<strong>规范化相等</strong>，就算它们实际上是由<em>不同的 <code>Unicode</code> 标量组合而成</em>。</p>
<p>比如说， <code>LATIN SMALL LETTER E WITH ACUTE</code> <em>( U+00E9)</em>是规范化相等于 <code>LATIN SMALL LETTER</code><em> E( U+0065)</em>加 <code>COMBINING ACUTE ACCENT</code> <em>( U+0301)</em>的。这两个扩展字形集群都是表示字符<code>é</code>的合法方式，所以它们被看做<em>规范化相等</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE</span></div><div class="line"><span class="keyword">let</span> eAcuteQuestion = <span class="string">"Voulez-vous un caf\u&#123;e9&#125;?"</span></div><div class="line"><span class="comment">// "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</span></div><div class="line"><span class="keyword">let</span> combinedEAuteQuestion = <span class="string">"Voulez-vous un caf\u&#123;65&#125;\u&#123;301&#125;"</span></div><div class="line"><span class="keyword">if</span> eAcuteQuestion == combinedEAuteQuestion &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"These two strings are considered equal"</span>) <span class="comment">// prints "These two strings are considered equal"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>反而， <code>LATIN CAPITAL LETTER A</code> ( <code>U+0041</code>, 或者说 “A”)在英语当中是不同于俄语的 <code>CYRILLIC CAPITAL LETTER A</code> ( U+0410,或者说 “А”)的。字符看上去差不多，但是它们拥有不同的语言意义，所以不相等。</p>
<h4 id="前缀和后缀相等性"><a href="#前缀和后缀相等性" class="headerlink" title="前缀和后缀相等性"></a>前缀和后缀相等性</h4><p>要检查一个字符串是否拥有特定的字符串前缀或者后缀，调用字符串的 <code>hasPrefix(_:)</code>和 <code>hasSuffix(_:)</code>方法，它们两个都会接受一个 <code>String</code> 类型的实际参数并且返回一个布尔量值。</p>
<p>举例，你可以使用 <code>hasPrefix(_:)</code>方法操作 <code>romeoAndJuliet</code>数组来计算第一场场景的数量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> romeoAndJuliet = [<span class="string">"Act 1 Scene 1: Verona, A public place"</span>,</div><div class="line">                      <span class="string">"Act 1 Scene 2: Capulet's mansion"</span>,</div><div class="line">                      <span class="string">"Act 1 Scene 3: A room in Capulet's mansion"</span>,</div><div class="line">                      <span class="string">"Act 1 Scene 4: A street outside Capulet's mansion"</span>,</div><div class="line">                      <span class="string">"Act 1 Scene 5: The Great Hall in Capulet's mansion"</span>,</div><div class="line">                      <span class="string">"Act 2 Scene 1: Outside Capulet's mansion"</span>,</div><div class="line">                      <span class="string">"Act 2 Scene 2: Capulet's orchard"</span>,</div><div class="line">                      <span class="string">"Act 2 Scene 3: Outside Friar Lawrence's cell"</span>,</div><div class="line">                      <span class="string">"Act 2 Scene 4: A street in Verona"</span>,</div><div class="line">                      <span class="string">"Act 2 Scene 5: Capulet's mansion"</span>,</div><div class="line">                      <span class="string">"Act 2 Scene 6: Friar Lawrence's cell"</span>]</div><div class="line"><span class="keyword">var</span> act1SceneCount = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</div><div class="line">    <span class="keyword">if</span> scene.hasPrefix(<span class="string">"Act 1"</span>) &#123;</div><div class="line">        act1SceneCount += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"There are <span class="subst">\(act1SceneCount)</span> scenes in Act 1"</span>)<span class="comment">// Prints "There are 5 scenes in Act 1"</span></div></pre></td></tr></table></figure>
<p>同样的，使用 <code>hasSuffix(_:)</code>方法来计算后缀可等性。</p>
<blockquote>
<p>如同字符串和字符相等性一节所描述的那样， <code>hasPrefix(_:)</code>和 <code>hasSuffix(_:)</code>方法只对字符串当中的每一个扩展字形集群之间进行了一个逐字符的规范化相等比较。</p>
</blockquote>
<h3 id="字符串的-Unicode-表示法"><a href="#字符串的-Unicode-表示法" class="headerlink" title="字符串的 Unicode 表示法"></a>字符串的 Unicode 表示法</h3><p>当一个 <code>Unicode</code> 字符串写入文本文档或者其他储存里边的时候，这个字符串的 <code>Unicode</code> 标量会被编码为<em>一个或者一系列</em> <code>Unicode</code> 定义的编码格式。每一种格式都把字符串编码成所谓<strong>码元的小块</strong>。这些包括 <code>UTF-8</code> 编码格式（它把字符串以8 码元编码），<code>UTF-16</code> 编码格式（它把字符串按照 16位 码元 编码），以及 <code>UTF-32</code> 编码格式（它把字符串以32位码元编码）。</p>
<p><code>Swift</code> 提供了几种不同的方法来访问字符串的 <code>Unicode</code> 表示。你可以使用 <code>for-in</code>语句来遍历整个字符串，来访以 <code>Unicode</code> <em>扩展字形集群</em>的方式，访问单独的 <code>Character</code>值。</p>
<p> 或者，你也可以用以下三者之一的其他 <code>Unicode</code> 兼容表示法来访问 <code>String</code>值：</p>
<ul>
<li><code>UTF-8</code> 码元的集合（关联于字符串的 <code>utf8</code>  属性）</li>
<li><code>UTF-16</code> 码元的集合（关联于字符串的 <code>utf16</code>  属性）</li>
<li><p>21位 <code>Unicode</code> 标量值的集合，等同于字符串的 <code>UTF-32</code> 编码格式（关联于字符串的 <code>unicodeScalars</code> 属性）</p>
<p>下边的每一个栗子都展示了接下来的字符串的不同表示方法，这个字符串由字符 <code>D ， o ， g ， ‼  ( DOUBLE EXCLAMATION MARK,</code> 或者说 <code>Unicode</code> 标量 <code>U+203C)</code>以及 <code>?</code> 字符<code>( DOG FACE , 或者说 Unicode 标量 U+1F436)</code>组成：</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> dogString = <span class="string">"Dog‼🐶"</span></div></pre></td></tr></table></figure>
<h4 id="UTF-8-表示法"><a href="#UTF-8-表示法" class="headerlink" title="UTF-8 表示法"></a>UTF-8 表示法</h4><p>你可以通过遍历 <code>utf8</code>属性来访问一个 <code>String</code>的 <code>UTF-8</code> 表示法。这个属性的类型是 <code>String.UTF8View</code>，它是非负8位（ <code>UInt8</code>）值，在字符串的 <code>UTF-8</code> 表示法中每一个字节的内容：<br> <img style="margin: auto," src="/2017/10/27/swift-stringAndCharacter/UTF8_2x.png" ,="" alt="UTF-8" title="UTF-8"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> dogString = <span class="string">"Dog‼🐶"</span></div><div class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf8 &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(codeUnit)</span>"</span>, terminator: <span class="string">" "</span>)</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">""</span>)</div><div class="line"><span class="comment">// 68 111 103 226 128 188 240 159 144 182</span></div></pre></td></tr></table></figure>
<p>上文中的栗子，前三个十进制 <code>codeUnit</code>值 <code>( 68, 111, 103)</code>表示了字符 D , o , 和 g ，它们的 <code>UTF-8</code> 表示法与它们的 <code>ASCII</code> 表示法相同。接下来的三个十进制 <code>codeUnit</code>值 <code>( 226, 128, 188)</code>是 <code>DOUBLE EXCLAMATION MARK</code>字符的三字节 <code>UTF-8</code>表示法。最后四个 <code>codeUnit</code>值 <code>( 240, 159, 144, 182)</code>是 <code>DOG FACE</code>字符的四字节 <code>UTF-8</code> 表示法。</p>
<h4 id="UTF-16-表示法"><a href="#UTF-16-表示法" class="headerlink" title="UTF-16 表示法"></a>UTF-16 表示法</h4><p>你可以通过遍历 <code>utf16</code>属性来访问 <code>String</code>的 <code>UTF-16</code>表示法。这个属性的类型是<code>String.UTF16View</code>，它是非负 <code>16位（ UInt16）</code>值，在字符串 <code>UTF-16</code> 表示法中每一个 16位 的内容：<br><img style="margin: auto," src="/2017/10/27/swift-stringAndCharacter/UTF16_2x.png" ,="" alt="UTF16" title="UTF16_表示法"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf16 &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(codeUnit)</span> "</span>, terminator: <span class="string">""</span>)</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">""</span>)</div><div class="line"><span class="comment">// Prints "68 111 103 8252 55357 56374 "</span></div></pre></td></tr></table></figure>
<p>再一次，前三个 <code>codeUnit</code>值 <code>( 68, 111, 103)</code>表示了字符 D , o , 和 g，它们的 <code>UTF-16</code> 码元与字符串 <code>UTF-8</code> 表示法中的值相同（因为这些 <code>Unicode</code> 标量表示 <code>ASCII</code> 字符）。</p>
<p>第四个 <code>codeUnit</code>值( <code>8252</code>)是与十六进制值 <code>203C</code>相等的十进制数字，它表示了 <code>DOUBLE EXCLAMATION MARK</code>字符的 <code>Unicode</code> 标量 <code>U+203C</code>。这个字符可以在 <code>UTF-16</code> 中表示为单个码元了。</p>
<p>第五和第六个 <code>codeUnit</code>值 ( <code>55357</code>和 <code>56374</code>)是 <code>UTF-16</code> 16位码元对表示的 DOG FACE字符。这些值是<strong>高</strong>16位码元值 <em>U+D83D</em>（十进制值为 <code>55357</code>）和<strong>低</strong>16位码元值 <em>U+DC36</em>（十进制值为 <code>56374</code>）。</p>
<h4 id="Unicode-标量表示法"><a href="#Unicode-标量表示法" class="headerlink" title="Unicode 标量表示法"></a>Unicode 标量表示法</h4><p>你可以通过遍历 <code>unicodeScalars</code>属性来访问 <code>String</code>值的 <code>Unicode</code> 标量表示法。这个属性的类型是 <code>UnicodeScalarView</code>，它是 <code>UnicodeScalar</code>类型值的合集。<br>每一个 <code>UnicodeScalar</code>都有值属性可以返回一个标量的21位值，用 <em>UInt32</em>值表示：<br><img style="margin: auto," src="/2017/10/27/swift-stringAndCharacter/UnicodeScalar_2x.png" alt="UnicodeScalar_2x.png" title="UnicodeScalar_表示法"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> codeUint <span class="keyword">in</span> dogString.unicodeScalars &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(codeUint.value)</span>"</span>, terminator: <span class="string">" "</span>)</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">""</span>)</div><div class="line"><span class="comment">// 68 111 103 8252 128054</span></div></pre></td></tr></table></figure>
<p>前三个 <code>UnicodeScalar</code>值的 <code>value</code>属性 <code>( 68, 111, 103)</code>还是表示了字符 D, o, 和 g。</p>
<p>第四个 <code>codeUnit</code>值 ( <code>8252</code>)还是等于十六进制值 <code>203C</code>的十进制值，它表示了<code>DOUBLE EXCLAMATION MARK</code>字符的 <code>Unicode</code> 标量 <code>U+203C</code>。</p>
<p>第五个和最后一个 <code>UnicodeScalar</code>的 <code>value</code>属性， <code>128054</code>，是一个等于十六进制值 <code>1F436</code>的十进制数字，它表示了 DOG FACE字符的 <code>Unicode</code> 标量 <code>U+1F436</code>。</p>
<p>作为查询它们 <code>value</code>属性的替代方法，每一个 <code>UnicodeScalar</code>值同样可以用来构造新的 <code>String</code>值，比如说使用字符串插值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> scalar <span class="keyword">in</span> dogString.unicodeScalars &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(scalar)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//D</span></div><div class="line"><span class="comment">//o</span></div><div class="line"><span class="comment">//g</span></div><div class="line"><span class="comment">//‼</span></div><div class="line"><span class="comment">//🐶</span></div></pre></td></tr></table></figure>
<blockquote>
<p>摘自：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" target="_blank" rel="external">swift 官网</a><br>所有代码在Xcode9 Swift4 环境编译没问题，代码<a href="https://github.com/keshiim/LearnSwift4" target="_blank" rel="external">戳这里 https://github.com/keshiim/LearnSwift4</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keshiim.github.io/2017/10/26/Swift-Operation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng keshiim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Farmer, keshiim 播种太阳🌞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/26/Swift-Operation/" itemprop="url">Swift：基础运算符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-26T16:07:46+08:00">
                2017-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/26/Swift-Operation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/26/Swift-Operation/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/10/26/Swift-Operation/" class="leancloud_visitors" data-flag-title="Swift：基础运算符">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>运算符</strong>是一种用来检查、改变或者合并值的特殊符号或组合符号。举例来说，加运算符<code>（ + ）</code>能够把两个数字相加（比如 <code>let i = 1 + 2</code>  ）。更复杂的栗子包括逻辑与运算 <code>&amp;&amp;</code>  比如 <code>if enteredDoorCode &amp;&amp; passedRetinaScan</code> 。</p>
<p><code>Swift</code> 在支持 <code>C</code> 中的大多数标准运算符的同时也增加了一些排除常见代码错误的能力。赋值符号<code>（ = ）</code>不会返回值，以防它被误用于等于符号<code>（ == ）</code>的意图上。算数符号<code>（ + , - , * , / , %  以及其他）</code>可以<strong>检测并阻止值溢出</strong>，以避免你在操作比储存类型允许的<strong>范围更大或者更小</strong>的数字时得到各种奇奇怪怪的结果。你可以通过使用 <code>Swift</code> 的溢出操作符来选择进入值溢出行为模式。</p>
<p><code>Swift</code> 提供了两种 <code>C</code> 中没有的区间运算符<code>（ a..&lt;b  和 a...b ）</code>，来让你便捷表达某个范围的值。</p>
<p>这个章节叙述了 <code>Swift</code> 语言当中常见的运算符。高级运算符 则涵盖了 <code>Swift</code> 中的高级运算符，同时描述了如何定义你自己的运算符以及在你自己的类当中实现标准运算符。</p>
<h3 id="专门用语"><a href="#专门用语" class="headerlink" title="专门用语"></a>专门用语</h3><p>运算符包括一元、二元、三元：</p>
<ul>
<li>一元运算符对<strong>一个目标</strong>进行操作（比如<code>-a</code>）。一元<em>前缀</em> 运算符在目标之前直接添加（比如<code>!b</code>），同事一元后缀运算符直接在目标末尾添加（比如<code>c!</code>）。</li>
<li>二元运算符对<strong>两个目标</strong>金鑫操作（比如<code>2 + 3</code>）同时因为他们出现在两个目标之间，所有是中缀。</li>
<li>三元运算符操作<strong>三个目标</strong>。如同 <code>C</code>，<code>Swift</code>语言也仅有一个三元运算符，三元条件运算符<code>（  a ? b : c ）</code>。</li>
</ul>
<p>受到运算符影响的值叫做<strong>操作数</strong>。在表达式 <code>1 + 2</code>  中， <code>+</code> 符号是一个<em>二元运算符</em>，其中的两个值 <code>1</code> 和 <code>2</code> 就是<em>操作数</em>。</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符<code>（ a = b ）</code>可以初始化或者更新 <code>a</code> 为 <code>b</code> 的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> b = <span class="number">10</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">4</span></div><div class="line">a = b <span class="comment">// a的值现在是10</span></div></pre></td></tr></table></figure>
<p>如果赋值符号右侧是<strong>拥有多个值的元组</strong>，它的元素将会一次性地拆分成<em>常量或者变量</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="comment">// x 等于 1, 同时 y 等于 2</span></div></pre></td></tr></table></figure>
<p>与 <code>Objective-C</code> 和 <code>C</code> 不同，<code>Swift</code> 的赋值符号自身不会返回值。下面的语句是不合法的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> x = y &#123;</div><div class="line">    <span class="comment">//这里不合法，因为x = y并不会返回任何值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个特性避免了赋值符号 <code>(=)</code> 被意外地用于等于符号 <code>(==)</code> 的实际意图上。<code>Swift</code> 通过让 <code>if x = y</code> 非法来帮助你避免这类的错误在你的代码中出现。</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><code>Swift</code> 对所有的数字类型支持四种标准算术运算符：<br>加 ( + )<br>减 ( - )<br>乘 ( * )<br>除 ( / )<br>与 <code>C</code> 和 <code>Objective-C</code> 中的算术运算符不同，<code>Swift</code> 算术运算符默认不允许值溢出。你可以选择使用 <code>Swift</code> 的溢出操作符（<code>比如  a &amp;+ b</code>）来行使溢出行为。<br>加法运算符同时也支持 String  的拼接：<code>“hello” + &quot;world&quot;</code></p>
<h4 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h4><p>余数运算符<code>（ a % b ）</code>可以求出多少个 <code>b</code> 的倍数能够刚好放进 <code>a</code>  中并且返回剩下的值（就是我们所谓的余数）。<br>当 <code>b</code>为负数时它的正负号被忽略掉了。这意味着 <code>a % b</code>  与 <code>a % -b</code>  能够获得相同的答案。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">9</span> % <span class="number">4</span> <span class="comment">// equals -1</span></div><div class="line">-<span class="number">9</span> % <span class="number">4</span> <span class="comment">// equals -1</span></div><div class="line"></div><div class="line"><span class="comment">//9 % -4 和 9 % 4 相等</span></div></pre></td></tr></table></figure>
<h4 id="一元减号运算符"><a href="#一元减号运算符" class="headerlink" title="一元减号运算符"></a>一元减号运算符</h4><p>数字值的正负号可以用前缀 <code>–</code> 来切换，我们称之为 一元减号运算符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> three = <span class="number">3</span></div><div class="line"><span class="keyword">let</span> minusThree = -three <span class="comment">// minusThree equals -3</span></div><div class="line"><span class="keyword">let</span> plusThree = -minusThree <span class="comment">// plusThree equals 3, or "minus minus three"</span></div></pre></td></tr></table></figure>
<h4 id="一元加号运算符"><a href="#一元加号运算符" class="headerlink" title="一元加号运算符"></a>一元加号运算符</h4><p>一元加号运算符 <code>（ + ）</code>直接返回它操作的值，不会对其进行任何的修改：<br>尽管一元加号运算符实际上什么也不做，你还是可以对正数使用它来<em>让你的代码对一元减号运算符来说显得更加对称</em>。感觉没什么用！！</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> minusSix = -<span class="number">6</span></div><div class="line"><span class="keyword">let</span> alsoMinusSix = +minusSix <span class="comment">// alsoMinusSix equals -6</span></div></pre></td></tr></table></figure>
<h3 id="组合赋值符号"><a href="#组合赋值符号" class="headerlink" title="组合赋值符号"></a>组合赋值符号</h3><p>如同 <code>C</code> ，<code>Swift</code> 提供了由赋值符号<code>（ = ）</code>和其他符号组成的 组合赋值符号 。一个加赋值符号的栗子 <code>（ += ）</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">c</span> = <span class="number">1</span></div><div class="line"><span class="built_in">c</span> += <span class="number">2</span> <span class="comment">// c is now equal to 3</span></div></pre></td></tr></table></figure>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><code>Swift</code> 支持所有 <code>C</code> 的标准比较运算符：</p>
<ul>
<li>相等 <code>( a == b )</code></li>
<li>不相等 <code>( a != b )</code></li>
<li>大于 <code>( a &gt; b )</code></li>
<li>小于 <code>( a &lt; b )</code></li>
<li>大于等于 <code>( a &gt;= b )</code></li>
<li>小于等于<code>( a &lt;= b )</code></li>
</ul>
<blockquote>
<p><code>Swift</code> 同时也提供两个等价运算符（<code>===  和 !== ）</code>，你可以使用它们来判断两个对象的引用是否相同。</p>
</blockquote>
<p>比较运算符通常被用在条件语句当中，比如说 <code>if</code>  语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">"world"</span></div><div class="line"><span class="keyword">if</span> name == <span class="string">"world"</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Hello, world"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"I`m sorry <span class="subst">\(name)</span>, but I don`t recongnize you"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你同样可以比较拥有<strong>同样数量值</strong>的<strong>元组</strong>，只要元组中的每个值都是<strong>可比较的</strong>。比如说， <code>Int</code> 和 <code>String</code> 都可以用来比较大小，也就是说 <code>(Int,String)</code> 类型的元组就可以<strong>比较</strong>。一般来说， <code>Bool</code> 不能比较，这意味着包含布尔值的元组不能用来比较大小。</p>
<p>元组以从左到右的顺序比较大小，一次一个值，<strong>直到找到两个不相等的值为止</strong>。如果所有的值都是相等的，那么就认为元组本身是相等的。比如说：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>, <span class="string">"zebra"</span>) &lt; (<span class="number">2</span>, <span class="string">"apple"</span>)   <span class="comment">// true because 1 is less than 2</span></div><div class="line">(<span class="number">3</span>, <span class="string">"apple"</span>) &lt; (<span class="number">3</span>, <span class="string">"bird"</span>)    <span class="comment">// true because 3 is equal to 3, and "apple" is less than "bird"</span></div><div class="line">(<span class="number">4</span>, <span class="string">"dog"</span>) == (<span class="number">4</span>, <span class="string">"dog"</span>)      <span class="comment">// true because 4 is equal to 4, and "dog" is equal to "dog"</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong><br><code>Swift</code> 标准库包含的元组比较运算符<strong>仅支持小于七个元素</strong>的元组。要比较拥有七个或者更多元素的元组，你必须自己实现比较运算符。</p>
<h3 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符"></a>三元条件运算符</h3><p>三元条件运算符是一种有三部分的特殊运算，它看起来是这样的： <code>question ? answer1 : answer2</code>。这是一种基于 <code>question</code>  是真还是假来选择两个表达式之一的便捷写法。如果 <code>question</code>  是真，则会判断为 <code>answer1</code>  并且返回它的值；否则，它判断为 <code>answer2</code>  并且返回它的值。<br>举个简单例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> question &#123;</div><div class="line">    answer1</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    answer2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并空值运算符"><a href="#合并空值运算符" class="headerlink" title="合并空值运算符"></a>合并空值运算符</h3><p>合并空值运算符 <code>（ a ?? b</code>）如果可选项 <code>a</code>  有值则展开，如果没有值，是 <code>nil</code>  ，则返回默认值 <code>b</code>。表达式 <code>a</code> 必须是一个可选类型。表达式 <code>b</code>  必须与 <code>a</code>  的储存类型相同。</p>
<p>合并空值运算符是下边代码的缩写：<code>a != nil ? a! : b</code></p>
<p>上边的代码中，三元条件运算符<strong>强制</strong>展开<code>（ a! ）</code>储存在 <code>a</code>  中的值，如果 <code>a</code> 不是 <code>nil</code>  的话，否则就返回<code>b</code>  的值。合并空值运算符提供了更加优雅的方式来封装这个条件选择和展开操作，让它更加简洁易读。</p>
<h3 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h3><p><code>Swift</code> 包含了两个 区间运算符 ，他们是表示一个范围的值的便捷方式。</p>
<h4 id="闭区间运算符"><a href="#闭区间运算符" class="headerlink" title="闭区间运算符"></a>闭区间运算符</h4><p>闭区间运算符<code>（ a...b ）</code>定义了从 <code>a</code>  到 <code>b</code>  的一组范围，并且包含 <code>a</code>  和 <code>b</code>  。 <code>a</code>  的值不能大于 <code>b</code> 。</p>
<p>遍历你需要用到的所有数字时，使用闭区间运算符是个不错的选择，比如说在 <code>for-in</code>  循环当中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(index)</span> times 5 is <span class="subst">\(index * <span class="number">5</span>)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1 times 5 is 5</span></div><div class="line"><span class="comment">// 2 times 5 is 10</span></div><div class="line"><span class="comment">// 3 times 5 is 15</span></div><div class="line"><span class="comment">// 4 times 5 is 20</span></div><div class="line"><span class="comment">// 5 times 5 is 25</span></div></pre></td></tr></table></figure>
<h4 id="半开区间运算符"><a href="#半开区间运算符" class="headerlink" title="半开区间运算符"></a>半开区间运算符</h4><p>半开区间运算符<code>（ a..&lt;b ）</code>定义了从 <code>a</code> 到 <code>b</code>  但不包括 <code>b</code>  的区间，即 <strong>半开</strong> ，因为它只包含起始值但并不包含结束值。（注：其实就是左闭右开区间。）如同闭区间运算符， <code>a</code>  的值也不能大于 <code>b</code> ，如果<code>a</code>  与 <code>b</code> 的值相等，那返回的区间将会是空的。</p>
<p>半开区间在遍历基于零开始序列比如说数组的时候非常有用，它从零开始遍历到数组长度（但是不包含）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Jack"</span>]</div><div class="line"><span class="keyword">let</span> <span class="built_in">count</span> = names.<span class="built_in">count</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Person <span class="subst">\(i + <span class="number">1</span>)</span> is called <span class="subst">\(names[i])</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Person 1 is called Anna</span></div><div class="line"><span class="comment">// Person 2 is called Alex</span></div><div class="line"><span class="comment">// Person 3 is called Brian</span></div><div class="line"><span class="comment">// Person 4 is called Jack</span></div></pre></td></tr></table></figure>
<h4 id="单侧区间"><a href="#单侧区间" class="headerlink" title="单侧区间"></a>单侧区间</h4><p>闭区间有另外一种形式来让区间朝一个方向尽可能的远——比如说，一个包含数组所有元素的区间，从索引 2 到数组的结束。在这种情况下，<em>你可以省略区间运算符一侧的值</em>。因为运算符只有一侧有值，所以这种区间叫做<strong>单侧区间</strong>。比如说：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="number">2</span>...] &#123;</div><div class="line">    <span class="built_in">print</span>(name)</div><div class="line">    <span class="comment">//Brian</span></div><div class="line">    <span class="comment">//Jack</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="number">1</span>...<span class="number">2</span>] &#123;</div><div class="line">    <span class="built_in">print</span>(name)</div><div class="line">    <span class="comment">//Alex</span></div><div class="line">    <span class="comment">//Brian</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>半开区间运算符</strong>同样可以有<strong>单侧形式</strong>，只需要写它最终的值。和你两侧都包含值一样，最终的值不是区间的一部分。举例来说：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[..&lt;<span class="number">2</span>] &#123;</div><div class="line">    <span class="built_in">print</span>(name)</div><div class="line">    <span class="comment">//Anna</span></div><div class="line">    <span class="comment">//Alex</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单侧区间也可以 <em>在其他上下文中使用</em> ，不仅仅是<em>下标</em>。你不能遍历省略了第一个值的单侧区间，因为遍历根本不知道该从哪里开始。你可以遍历省略了最终值的单侧区间；总之，由于区间无限连续，你要确保给循环添加一个显式的条件。你同样可以检测单侧区间是否包含特定的值，就如下面的代码所述。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> range = ...<span class="number">5</span></div><div class="line">range.<span class="built_in">contains</span>(<span class="number">9</span>) <span class="comment">//false</span></div><div class="line">range.<span class="built_in">contains</span>(<span class="number">4</span>) <span class="comment">//true</span></div><div class="line">range.<span class="built_in">contains</span>(-<span class="number">1</span>)<span class="comment">//true</span></div></pre></td></tr></table></figure>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符可以修改或者合并布尔逻辑值 <code>true</code>  和 <code>false</code>  。<code>Swift</code> 支持三种其他基于 <code>C</code> 的语言也包含的标准逻辑运算符</p>
<ul>
<li>逻辑 非（!a）</li>
<li>逻辑 与（a &amp;&amp; b）</li>
<li>逻辑 或（a || b）</li>
</ul>
<h4 id="逻辑非运算符"><a href="#逻辑非运算符" class="headerlink" title="逻辑非运算符"></a>逻辑非运算符</h4><p>逻辑非运算符<code>（ !a ）</code>会转换布尔值，把 <code>true</code>  变成 <code>false</code>  ， 把 <code>false</code>  变成 <code>true</code> </p>
<h4 id="逻辑与运算符"><a href="#逻辑与运算符" class="headerlink" title="逻辑与运算符"></a>逻辑与运算符</h4><p>逻辑与运算符<code>（ a &amp;&amp; b ）</code>需要逻辑表达式的两个值都为 <code>true</code>  ，整个表达式的值才为 <code>true</code> 。</p>
<p>如果任意一个值是 <code>false</code>  ，那么整个表达式的结果会是 <code>false</code>  。事实上，如果第一个值是 <code>false</code>  ，那么第二个值就会被忽略掉了，因为它已经无法让整个表达式再成为 <code>true</code>  。这就是所谓的 短路计算 。</p>
<h4 id="逻辑或运算符"><a href="#逻辑或运算符" class="headerlink" title="逻辑或运算符"></a>逻辑或运算符</h4><p>逻辑或运算符<code>（ a || b ）</code>是一个中缀运算符，它由两个相邻的管道字符组成。你可以使用它来创建两个值之间只要有一个为 <code>true</code>  那么整个表达式就是 <code>true</code>  的逻辑表达式。</p>
<p>如同上文中的逻辑与运算符，逻辑或运算符也使用短路计算来判断表达式。如果逻辑或运算符左侧的表达式为 <code>true</code>  ， <em>那么右侧则不予考虑了，因为它不会影响到整个逻辑表达式的结果。</em><br>你可以组合多个逻辑运算符来创建一个更长的组合表达式：</p>
<h4 id="混合逻辑运算"><a href="#混合逻辑运算" class="headerlink" title="混合逻辑运算"></a>混合逻辑运算</h4><p>你可以组合多个逻辑运算符来创建一个更长的组合表达式：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个栗子使用了多个 &amp;&amp;  和 ||  运算符来创建组合表达式。不过， &amp;&amp; 和 ||  仍旧只能够操作两个值，它实际上是三个更小的表达式链接而成。这个栗子可以读作：</p>
<p>如果我们输入了正确的密码并通过了视网膜扫描，或者如果我们有合法的钥匙或者我们知道紧急超驰密码，就允许进入。</p>
<p><strong>注意：</strong><br><code>Swift</code> 语言中逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code>是<strong>左相关</strong>的，这意味着多个逻辑运算符组合的表达式会<strong>首先计算最左边的子表达式</strong>。</p>
<h4 id="显式括号"><a href="#显式括号" class="headerlink" title="显式括号"></a>显式括号</h4><p>很多时候虽然不被要求，但使用括号还是很有用的，这能让复杂的表达式更容易阅读。在上文当中的门禁栗子里，把前边部分的表达式用圆括号括起来就会让整个组合表达式的意图更加明显：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints "Welcome!"</span></div></pre></td></tr></table></figure>
<p>圆括号把前边的两个值单独作为一部分来考虑，这样使整个表达式的意图清晰明显。组合表达式的输出并没有改变，但是整个意图变得清晰易读。 <em>可读性永远是第一位的</em> ；当需要的时候，使用圆括号让你的意图更加明确</p>
<blockquote>
<p>摘自：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" target="_blank" rel="external">swift 官网</a><br>所有代码在Xcode9 Swift4 环境编译没问题，代码<a href="https://github.com/keshiim/LearnSwift4" target="_blank" rel="external">戳这里 https://github.com/keshiim/LearnSwift4</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keshiim.github.io/2017/10/26/Swift-base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng keshiim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Farmer, keshiim 播种太阳🌞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/26/Swift-base/" itemprop="url">Swift：基础内容</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-26T11:44:30+08:00">
                2017-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/26/Swift-base/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/26/Swift-base/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/10/26/Swift-base/" class="leancloud_visitors" data-flag-title="Swift：基础内容">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><p><code>Swift</code> 为所有 <code>C</code> 和 <code>Objective-C</code> 的类型提供了自己的版本，包括整型值的 Int ，浮点数值的 <code>Double</code> 和 <code>Float</code> ，布尔量值的 <code>Bool</code> ，字符串值的 <code>String</code> 。如同集合类型中描述的那样， <code>Swift</code> 同样也为三个主要的集合类型提供了更高效的版本， <code>Array</code> ， <code>Set</code> 和 <code>Dictionary</code> 。</p>
<p>和 <code>C</code> 一样，<code>Swift</code> 用变量存储和调用值，通过变量名来做区分。<code>Swift</code> 中也大量采用了值不可变的变量。它们就是所谓的常量，但是它们比 <code>C</code> 中的常量更加给力。当你所处理的值不需要更改时，使用常量会让你的代码更加安全、简洁地表达你的意图。</p>
<p>除了我们熟悉的类型以外，<code>Swift</code> 还增加了 <code>Objective-C</code> 中没有的类型，比如元组。元组允许你来创建和传递一组数据。你可以利用元组在一个函数中以单个复合值的形式返回多个值。</p>
<p>Swift 还增加了可选项，用来处理没有值的情况。可选项意味着要么“这里有一个值，它等于 x”要么“这里根本没有值”。可选项类似于 <code>Objective-C</code> 中的 <code>nil</code> 指针，但是不只是类，可选项也可以用在所有的类型上。可选项比 <code>Objective-C</code> 中的 <code>nil</code> 指针更安全、更易读，他也是 <code>Swift</code> 语言中许多重要功能的核心。</p>
<p>可选项充分证明了 <code>Swift</code> 是一门类型安全的语言。<code>Swift</code> 帮助你明确代码可以操作值的类型。如果你的一段代码预期得到一个 <code>String</code> ，类型会安全地阻止你不小心传入 <code>Int</code> 。在开发过程中，这个限制能帮助你在开发过程中更早地发现并修复错误。</p>
<h3 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h3><p><strong>常量</strong>和<strong>变量</strong>是把名字和一个特定类型的值关联起来。<em>常量：值一旦设置好不能更改</em>，然而，<em>变量：可以在将来被设置为不同的值</em></p>
<h4 id="声明常量和变量"><a href="#声明常量和变量" class="headerlink" title="声明常量和变量"></a>声明常量和变量</h4><p>常量和变量必须在使用前被声明，使用关键字 <code>let</code> 来声明常量，使用关键字 <code>var</code> 来声明变量。举一个如何利用常量和变量记录用户登录次数的栗子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> maximumNumberOfLoginAttempts = <span class="number">10</span></div><div class="line"><span class="keyword">var</span> currentLoginAttempt = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>这段代码可以读作：<br>“声明一个叫做 <code>maximumNumberOfLoginAttempts</code> 的新常量，并设置值为 <code>10</code> 。然后声明一个叫做 <code>currentLoginAttempt</code> 的新变量, 并且给他一个初始值 <code>0</code>。”</p>
<p>你可以在一行中声明多个变量或常量，用逗号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span>, z = <span class="number">0.0</span> <span class="comment">//一行声明</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：在你的代码中，如果存储的值不会改变，请用 <code>let</code> 关键字将之声明为一个常量。只有储存会改变的值时才使用变量。</p>
</blockquote>
<h4 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h4><p>你可以在声明一个变量或常量的时候提供<strong>类型标注</strong>，来明确变量或常量能够<strong>储存值的类型</strong>。添加类型标注的方法是在变量或常量的名字后边加一个冒号，再跟一个空格，最后加上要使用的类型名称。<br>下面声明一个叫<code>welcomeMessage</code>的变量，并明确指定变量存储<code>String</code>类型的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span> <span class="comment">//明确指定String类型的变量welcomeMessage</span></div></pre></td></tr></table></figure>
<p>现在这个 welcomeMessage 变量就可以被设置到任何字符串中而不会报错了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">welcomeMessage = <span class="string">"Hello"</span></div></pre></td></tr></table></figure>
<p>你可以在一行中定义多个相关的变量为相同的类型，用<strong>逗号</strong>分隔，只要在<strong>最后的变量名字后边加上类型标注</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> red, green, blue: <span class="type">Double</span></div></pre></td></tr></table></figure>
<h4 id="命名常量和变量"><a href="#命名常量和变量" class="headerlink" title="命名常量和变量"></a>命名常量和变量</h4><p>常量和变量的名字<strong>几乎可以使用任何字符</strong>，甚至包括 <strong>Unicode</strong> 字符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> π = <span class="number">3.141592653</span></div><div class="line"><span class="keyword">let</span> 你好 = <span class="string">"你好啊swift"</span></div><div class="line"><span class="keyword">let</span> 🐂🐶 = <span class="string">"cowdog"</span></div></pre></td></tr></table></figure>
<p>常量和变量的名字不能包含<em>空白字符</em>、<em>数学符号</em>、<em>箭头</em>、<em>保留的（或者无效的）Unicode 码位</em>、<em>连线</em>和<em>制表符</em>。也<strong>不能以数字开头</strong>，尽管数字几乎可以使用在名字其他的任何地方。</p>
<p>一旦你声明了一个确定类型的常量或者变量，就不能使用相同的名字再次进行声明，也不能让它改存其他类型的值。常量和变量之间也不能互换。<br>如果你需要使用 Swift 保留的关键字来给常量或变量命名，可以使用反引号（ ` ）包围它来作为名称。总之，除非别无选择，避免使用关键字作为名字除非你确实别无选择。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> `<span class="keyword">let</span>` = <span class="string">"let"</span></div><div class="line"><span class="built_in">print</span>(`<span class="keyword">let</span>`)</div></pre></td></tr></table></figure>
<p>你可以把现有<strong>变量</strong>的值更改为其他相同类型的值。在这个栗子中 <code>friendlyWelcome</code>  的值从 “Hello!” 改变为 “Bonjour!”。不同于变量，<strong>常量</strong>的值一旦设定则不能再被改变。尝试这么做将会在你代码编译时导致报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> friendlyWelcome = <span class="string">"Hello!"</span></div><div class="line">friendlyWelcome = <span class="string">"Bonjour!"</span> <span class="comment">// friendlyWelcome 现在是 "Bonjour!"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> languageName = <span class="string">"Swift"</span></div><div class="line">languageName = <span class="string">"Swift++"</span> <span class="comment">// this is a compile-time error - languageName cannot be changed</span></div></pre></td></tr></table></figure>
<h4 id="输出常量和变量"><a href="#输出常量和变量" class="headerlink" title="输出常量和变量"></a>输出常量和变量</h4><p>你可以使用 <code>print(_:separator:terminator:)</code> 函数来打印当前常量和变量中的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(friendlyWelcome) <span class="comment">// 输出 “Bonjour!”</span></div></pre></td></tr></table></figure>
<p><code>Swift</code> 使用字符串插值 的方式来把常量名或者变量名当做占位符加入到更长的字符串中，然后让 <code>Swift</code> 用常量或变量的当前值替换这些占位符。将常量或变量名放入圆括号中并在括号前使用反斜杠将其转义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"The current value of friendlyWelcome is <span class="subst">\(friendlyWelcome)</span>"</span>)</div><div class="line"><span class="comment">// 输出 "The current value of friendlyWelcome is Bonjour!"</span></div></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>Swift</code>注释和其他语言形式一样，略了不谈</p>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>和许多其他的语言不同，<code>Swift</code> 并不要求你在每一句代码结尾写分号<code>（ ; ）</code>，当然如果你想写的话也没问题。总之，如果你想在<strong>一行里写多句代码</strong>，<strong>分号</strong>还是需要的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> cat = <span class="string">"🐱"</span>; <span class="built_in">print</span>(cat)</div><div class="line"><span class="comment">// 输出 "🐱"</span></div></pre></td></tr></table></figure>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>数就是没有小数部分的数字，比如 42 和 -23 。整数可以是有符号（正，零或者负），或者无符号（正数或零）。</p>
<p><code>Swift</code> 提供了 8，16，32 和 64 位编码的有符号和无符号整数，这些整数类型的命名方式和 C 相似，例如 8 位无符号整数的类型是 <code>UInt8</code> ，32 位有符号整数的类型是 <code>Int32</code> 。与 <code>Swift</code> 中的其他类型相同，这些整数类型也用开头大写命名法。</p>
<h4 id="整数范围"><a href="#整数范围" class="headerlink" title="整数范围"></a>整数范围</h4><p>你可以通过 <code>min</code> 和 <code>max</code> 属性来访问每个整数类型的最小值和最大值:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> minValue = <span class="type">UInt8</span>.<span class="built_in">min</span> <span class="comment">//0</span></div><div class="line"><span class="keyword">let</span> maxValue = <span class="type">UInt8</span>.<span class="built_in">max</span> <span class="comment">//255</span></div></pre></td></tr></table></figure>
<h4 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h4><p>在大多数情况下，你不需要在你的代码中为整数设置一个特定的长度。Swift 提供了一个额外的整数类型： Int ，它拥有与当前平台的原生字相同的长度。</p>
<ul>
<li>在32位平台上， <code>Int</code> 的长度和 <code>Int32</code> 相同。</li>
<li>在64位平台上， <code>Int</code> 的长度和 <code>Int64</code> 相同。</li>
</ul>
<p>除非你需操作特定长度的整数，否则请尽量在代码中使用 Int 作为你的整数的值类型。这样能提高代码的统一性和兼容性，即使在 32 位的平台上， Int 也可以存 -2,147,483,648 到 2,147,483,647 之间的任意值，对于大多数整数区间来说完全够用了。</p>
<h4 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a>UInt</h4><p><code>Swift</code> 也提供了一种无符号的整数类型， <code>UInt</code> ，它和当前平台的原生字长度相同。</p>
<ul>
<li>在32位平台上， <code>UInt</code> 长度和 <code>UInt32</code> 长度相同。</li>
<li>在64位平台上， <code>UInt</code> 长度和 <code>UInt64</code> 长度相同。</li>
</ul>
<blockquote>
<p>只在的确需要存储一个和当前平台原生字长度相同的无符号整数的时候才使用 <code>UInt</code> 。其他情况下，推荐使用 <code>Int</code> ，即使已经知道存储的值都是非负的。如同类型安全和类型推断中描述的那样，统一使用 <code>Int</code>  会提高代码的兼容性，同时可以避免不同数字类型之间的转换问题，也符合整数的类型推断。</p>
</blockquote>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数是有小数的数字，比如 3.14159 , 0.1 , 和 -273.15 。<br>浮点类型相比整数类型来说能表示<strong>更大范围</strong>的值，可以存储比 <code>Int</code> 类型更大或者更小的数字。<code>Swift</code> 提供了两种有符号的浮点数类型。</p>
<ul>
<li>Double代表 64 位的浮点数。</li>
<li>Float 代表 32 位的浮点数。</li>
</ul>
<blockquote>
<p>注：<code>Double</code> 有至少 15 位数字的精度，而 <code>Float</code> 的精度只有 6 位。具体使用哪种浮点类型取决于你代码需要处理的值范围。在两种类型都可以的情况下，推荐使用 <code>Double</code> 类型。</p>
</blockquote>
<h3 id="类型安全和类型推断"><a href="#类型安全和类型推断" class="headerlink" title="类型安全和类型推断"></a>类型安全和类型推断</h3><p>Swift 是一门类型安全的语言。类型安全的语言可以让你清楚地知道代码可以处理的值的类型。如果你的一部分代码期望获得 <code>String</code> ，你就不能错误的传给它一个 <code>Int</code> 。</p>
<p>因为 Swift 是类型安全的，他在编译代码的时候会进行类型检查，任何不匹配的类型都会被标记为错误。这会帮助你在开发阶段更早的发现并修复错误。</p>
<p>当你操作不同类型的值时，类型检查能帮助你避免错误。当然，这并不意味着你得为每一个常量或变量声明一个特定的类型。如果你没有为所需要的值进行类型声明，<code>Swift</code> 会使用类型推断的功能推断出合适的类型。通过检查你给变量赋的值，类型推断能够在编译阶段自动的推断出值的类型。</p>
<p>因为有了类型推断，<code>Swift</code> 和 <code>C</code> 以及 <code>Objective-C</code> 相比，只需要少量的类型声明。其实常量和变量仍然需要明确的类型，但是大部分的声明工作 Swift 会帮你做。</p>
<p>在你为一个变量或常量设定一个初始值的时候，类型推断就显得更加有用。它通常在你声明一个变量或常量同时设置一个初始的字面量（文本）时就已经完成。（字面量就是会直接出现在你代码中的值，比如下边代码中的 <code>42</code> 和 <code>3.14159</code>。）</p>
<p>举个栗子，如果你给一个新的常量设定一个 <code>42</code> 的字面量，而且没有说它的类型是什么，<code>Swift</code> 会推断这个常量的类型是 <code>Int</code> ，因为你给这个常量初始化为一个看起来像是一个整数的数字。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> meaningOfLife = <span class="number">42</span></div><div class="line"><span class="comment">// meaningOfLife is inferred to be of type Int</span></div></pre></td></tr></table></figure>
<p>同样，如果你没有为一个浮点值的字面量设定类型，Swift 会推断你想创建一个 Double 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> pi = <span class="number">3.14159</span></div><div class="line"><span class="comment">// pi is inferred to be of type Double</span></div></pre></td></tr></table></figure>
<p>Swift 在推断浮点值的时候始终会选择 <code>Double</code> （而不是 <code>Float</code> ）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> anotherPi = <span class="number">3</span> + <span class="number">0.14159</span></div><div class="line"><span class="comment">// anotherPi is also inferred to be of type Double</span></div></pre></td></tr></table></figure>
<p>这字面量 <code>3</code> 没有显式的声明它的类型，但因为后边有一个浮点类型的字面量，所以这个类型就被推断为 <code>Double</code>。</p>
<h3 id="数值型字面量"><a href="#数值型字面量" class="headerlink" title="数值型字面量"></a>数值型字面量</h3><p>整数型字面量可以写作：</p>
<ul>
<li>一个十进制数，没有前缀</li>
<li>一个二进制数，前缀是 <code>0b</code></li>
<li>一个八进制数，前缀是 <code>0o</code></li>
<li>一个十六进制数，前缀是 <code>0x</code></li>
</ul>
<p>例子：下面的这些所有整数字面量的十进制值都是 17  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> decimalInteger = <span class="number">17</span></div><div class="line"><span class="keyword">let</span> binaryInteger = <span class="number">0b10001</span> <span class="comment">// 17 in binary notation</span></div><div class="line"><span class="keyword">let</span> octalInteger = <span class="number">0o21</span> <span class="comment">// 17 in octal notation</span></div><div class="line"><span class="keyword">let</span> hexadecimalInteger = <span class="number">0x11</span> <span class="comment">// 17 in hexadecimal notation</span></div></pre></td></tr></table></figure>
<p>浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是 <code>0x</code> ）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。十进制的浮点字面量还有一个<strong>可选的指数</strong>，用大写或小写的 <code>e</code> 表示；十六进制的浮点字面量<strong>必须有指数</strong>，用大写或小写的 <code>p</code> 来表示。</p>
<p>十进制数与 <code>exp</code>  的指数，结果就等于基数乘以 $10^{exp}$：</p>
<ul>
<li>1.25e2 意味着 1.25 x $10^2$, 或者 125.0 .</li>
<li>1.25e-2  意味着 1.25 x $10^{-2}$, 或者 0.0125 .</li>
</ul>
<p>下面的这些浮点字面量的值都是十进制的 12.1875 ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> decimalDouble = <span class="number">12.1875</span></div><div class="line"><span class="keyword">let</span> exponentDouble = <span class="number">1.21875e1</span></div><div class="line"><span class="keyword">let</span> hexadecimalDouble = <span class="number">0xC.3p0</span> <span class="comment">//小数部分的换算是：16 x 0.1875 = 3</span></div></pre></td></tr></table></figure>
<p>数值型字面量也可以增加额外的<strong>格式</strong>使代码更加易读。整数和浮点数都可以添加额外的<strong>零</strong>或者添加<strong>下划线</strong>来增加代码的可读性。下面的这些格式都不会影响字面量的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> paddedDouble = <span class="number">000123.456</span></div><div class="line"><span class="keyword">let</span> oneMillon = <span class="number">1_000_000</span></div><div class="line"><span class="keyword">let</span> justOverOneMillion = <span class="number">1_000_000.000_000_1</span></div></pre></td></tr></table></figure>
<h3 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h3><p>通常来讲，即使我们知道代码中的整数变量和常量是非负的，我们也会使用 <code>Int</code> 类型。经常使用默认的整数类型可以确保你的整数常量和变量可以直接被复用并且符合整数字面量的类型推测。</p>
<p>只有在特殊情况下才会使用整数的其他类型，例如需要处理外部长度明确的数据或者为了优化性能、内存占用等其他必要情况。在这些情况下，使用指定长度的类型可以帮助你及时发现意外的<code>值溢出</code>和<code>隐式</code>记录正在使用数据的本质。</p>
<h4 id="整数转换"><a href="#整数转换" class="headerlink" title="整数转换"></a>整数转换</h4><p>不同整数的类型在变量和常量中存储的数字范围是不同的。 <code>Int8</code> 类型的常量或变量可以存储的数字范围是 -128~127，而 <code>UInt8</code> 类型的常量或者变量能存储的数字范围是 0~255 。如果数字超出了常量或者变量可存储的范围，编译的时候就会报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> cannotBeNegative: <span class="type">UInt8</span> = -<span class="number">1</span></div><div class="line"><span class="comment">// UInt8 cannot store negative numbers, and so this will report an error</span></div><div class="line"><span class="keyword">let</span> tooBig: <span class="type">Int8</span> = <span class="type">Int8</span>.<span class="built_in">max</span> + <span class="number">1</span></div><div class="line"><span class="comment">// Int8 cannot store a number larger than its maximum value,</span></div><div class="line"><span class="comment">// and so this will also report an error</span></div></pre></td></tr></table></figure>
<p>因为每个数值类型可存储的值的范围不同，你必须根据不同的情况进行数值类型的转换。这种选择性使用的方式可以<strong>避免隐式转换</strong>的错误并使你代码中的类型转换<strong>意图更加清晰</strong>。</p>
<p>例子：要将一种数字类型转换成另外一种类型，你需要用当前值来初始化一个期望的类型。在下面的栗子中，常量 <code>twoThousand</code> 的类型是 <code>UInt16</code> ，而常量 <code>one</code> 的类型是 <code>UInt8</code> 。他们不能直接被相加在一起，因为他们的类型不同。所以，这里让 <code>UInt16</code> <code>(one )</code> 创建一个新的 <code>UInt16</code> 类型并用 <code>one</code> 的值初始化，这样就可以在原来的地方使用了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> twoThousand: <span class="type">UInt16</span> = <span class="number">2_000</span></div><div class="line"><span class="keyword">let</span> one: <span class="type">UInt8</span> = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> twoThousandAndOne = twoThousand + <span class="type">UInt16</span>(one)</div></pre></td></tr></table></figure>
<p>因为加号两边的类型现在都是  <code>UInt16</code> ，所以现在是可以相加的。输出的常量（ <code>twoThousandAndOne</code> ）被推断为 <code>UInt16</code> 类型，因为他是两个 <code>UInt16</code> 类型的和。</p>
<p><code>SomeType(ofInitialValue)</code>  是调用 <code>Swift</code> 类型初始化器并传入一个初始值的默认方法。在语言的内部， <code>UInt16</code> 有一个初始化器，可以接受一个 <code>UInt8</code> 类型的值，所以这个初始化器可以用现有的 UInt8来创建一个新的 UInt16 。这里需要注意的是并不能传入任意类型的值，只能传入 <code>UInt16</code> 内部有对应初始化器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型）。</p>
<h4 id="整数和浮点数转换"><a href="#整数和浮点数转换" class="headerlink" title="整数和浮点数转换"></a>整数和浮点数转换</h4><p>整数和浮点数类型的转换必须显式地指定类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> three = <span class="number">3</span></div><div class="line"><span class="keyword">let</span> pointOneFourOneFiveNine = <span class="number">0.14159</span></div><div class="line"><span class="keyword">let</span> pi = <span class="type">Double</span>(three) + pointOneFourOneFiveNine</div><div class="line"><span class="comment">// pi equals 3.14159, and is inferred to be of type Double</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> integerPi = <span class="type">Int</span>(pi)</div><div class="line"><span class="comment">// integerPi equals 3, and is inferred to be of type Int</span></div></pre></td></tr></table></figure>
<p>浮点转换为整数也必须显式地指定类型。一个整数类型可以用一个 <code>Double</code> 或者 <code>Float</code> 值初始化。<br>在用浮点数初始化一个新的整数类型的时候，数值会被截断。也就是说<code>4.75</code> 会变成 <code>4</code> ， <code>-3.9</code>会变为 <code>-3</code>。</p>
<blockquote>
<p>结合数字常量和变量的规则与结合数字字面量的规则不同，字面量 <code>3</code> 可以直接和字面量<code>0.14159</code> 相加，因为数字字面量本身没有明确的类型。它们的类型只有在编译器需要计算的时候才会被推测出来。</p>
</blockquote>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名可以为已经存在的类型定义了一个新的可选名字。用 <code>typealias</code> 关键字定义类型别名。</p>
<p>当你根据上下文的语境想要给类型一个更有意义的名字的时候，类型别名会非常高效，例如处理外部资源中特定长度的数据时：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> = <span class="type">UInt16</span></div></pre></td></tr></table></figure>
<p>一旦为类型创建了一个别名，你就可以在任何使用原始名字的地方使用这个别名。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>Swift</code> 有一个基础的布尔量类型，就是 <code>Bool</code> ，布尔量被作为逻辑值来引用，因为他的值只能是真或者假。<code>Swift</code>为布尔量提供了两个常量值， <code>true</code> 和 <code>false</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> orangesAreOrange = <span class="literal">true</span></div><div class="line"><span class="keyword">let</span> turnipsAreDelicious = <span class="literal">false</span></div><div class="line"><span class="keyword">if</span> trunipsAreDelicious &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Mmm, tasty turnips!"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Eww, turnips are horrible."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Swift</code> 的类型安全机制会阻止你用一个非布尔量的值替换掉 <code>Bool</code> 。下面的栗子中报告了一个发生在编译时的错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> i = <span class="number">1</span></div><div class="line"><span class="keyword">if</span> i &#123; <span class="comment">// 编译报错</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组把多个值合并成单一的<strong>复合型</strong>的值。元组内的值可以是任何类型，而且可以不必是同一类型。<br>在下面的示例中， <code>(404, &quot;Not Found&quot;)</code> 是一个描述了 <code>HTTP</code> 状态代码 的元组。<code>HTTP</code> 状态代码是当你请求网页的时候 web 服务器返回的一个特殊值。当你请求不存在的网页时，就会返回  <code>404 Not Found</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> http404Error = (<span class="number">404</span>, <span class="string">"Not Found"</span>)</div><div class="line"><span class="comment">// http404Error is of type (Int, String), and equals (404, "Not Found")</span></div></pre></td></tr></table></figure>
<p><code>(404, &quot;Not Found&quot;)</code> 元组把一个 <code>Int</code>  和一个 <code>String</code>  组合起来表示 <code>HTTP</code> 状态代码的两种不同的值：数字和人类可读的描述。他可以被描述为“一个类型为 <code>(Int, String)</code>  的元组”</p>
<p>任何类型的排列都可以被用来创建一个元组，他可以包含任意多的类型。例如 <code>(Int, Int, Int)</code> 或者 <code>(String, Bool)</code> ，实际上，任何类型的组合都是可以的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> (statusCode, statusMessage) = http404Error</div><div class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(statusCode)</span>"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"The status message is <span class="subst">\(statusMessage)</span>"</span>)</div><div class="line"><span class="comment">//另外一种方法就是利用从零开始的索引数字访问元组中的单独元素</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(http404Error.<span class="number">0</span>)</span>"</span>) </div><div class="line"><span class="built_in">print</span>(<span class="string">"The status message is <span class="subst">\(http404Error.<span class="number">1</span>)</span>"</span>)</div></pre></td></tr></table></figure>
<p>当你分解元组的时候，如果只需要使用其中的一部分数据，不需要的数据可以用下滑线（ _ ）代替：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="number">_</span>) = http404Error</div><div class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(justTheStatusCode)</span>"</span>)</div></pre></td></tr></table></figure>
<p>你可以在定义元组的时候给其中的单个元素命名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> http200Status = (statusCode: <span class="number">200</span>, description: <span class="string">"OK"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"The status code is  <span class="subst">\(http200Status.statusCode)</span>"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"The status description is  <span class="subst">\(http200Status.<span class="number">1</span>)</span>"</span>)</div></pre></td></tr></table></figure>
<p>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个 <code>(Int, String)</code> 元组来描述是否获取成功。相比只能返回一个类型的值，元组能包含两个不同类型值，他可以让函数的返回信息更有用。更多内容请参考多返回值的函数。</p>
<h3 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h3><p>可以利用<strong>可选项</strong>来处理值可能缺失的情况。可选项意味着：<br>· 这里有一个值，他等于<code>x</code><br>或者<br>· 这里根本没有值</p>
<blockquote>
<p>在 <code>C</code> 和 <code>Objective-C</code> 中，没有可选项的概念。在 <code>Objective-C</code> 中有一个近似的特性，一个方法可以返回一个对象或者返回 <code>nil</code> 。 <code>nil</code> 的意思是“缺少一个可用对象”。然而，他只能用在对象上，却不能作用在结构体，基础的 <code>C</code> 类型和枚举值上。对于这些类型，<code>Objective-C</code> 会返回一个特殊的值（例如 <code>NSNotFound</code> ）来表示值的缺失。这种方法是建立在假设调用者知道这个特殊的值并记得去检查他。然而，<code>Swift</code> 中的可选项就可以让你知道任何类型的值的缺失，他并不需要一个特殊的值。</p>
</blockquote>
<p>下面的栗子演示了可选项如何作用于值的缺失，<code>Swift</code> 的 <code>Int</code> 类型中有一个初始化器，可以将 <code>String</code> 值转换为一个 <code>Int</code> 值。然而并不是所有的字符串都可以转换成整数。字符串 <code>“123”</code> 可以被转换为数字值 <code>123</code>  ，但是字符串  <code>&quot;hello, world&quot;</code> 就显然不能转换为一个数字值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> possibleNumber = <span class="string">"123"</span></div><div class="line"><span class="keyword">let</span> convertedNumber = <span class="type">Int</span>(possibleNumber) <span class="comment">// convertedNumber is inferred to be of type "Int?", or "optional Int"</span></div></pre></td></tr></table></figure>
<p>因为这个初始化器可能会失败，所以他会返回一个可选的 <code>Int</code> ，而不是 <code>Int</code> 。可选的 <code>Int</code> 写做 <code>Int?</code>，而不是 <code>Int</code> 。问号明确了它储存的值是一个可选项，意思就是说它可能包含某些 <code>Int</code>  值，或者可能根本不包含值。（他不能包含其他的值，例如 <code>Bool</code> 值或者 <code>String</code> 值。它要么是 <code>Int</code> 要么什么都没有。）</p>
<h4 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h4><p>你可以通过给可选变量赋值一个<code>nil</code>来将之设置为没有值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> serverResponseCode: <span class="type">Int</span>? = <span class="number">404</span></div><div class="line">serverResponseCode = <span class="literal">nil</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong><code>nil</code> 不能用于<em>非可选</em>的常量或者变量，如果你的代码中变量或常量需要作用于特定条件下的值缺失，可以给他声明为相应类型的可选项。</p>
<p>如果你定义的可选变量没有提供一个默认值，变量会被自动设置成 <code>nil</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> surveyAnswer: <span class="type">String</span>?</div><div class="line"><span class="comment">// surveyAnswer is automatically set to nil</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong><code>Swift</code> 中的 <code>nil</code> 和<code>Objective-C</code> 中的 <code>nil</code> 不同，在 <code>Objective-C</code> 中 <code>nil</code> 是一个指向不存在对象的指针。在 <code>Swift</code>中， <code>nil</code> <strong>不是指针</strong>，他是值缺失的一种特殊类型，任何类型的可选项都可以设置成 <code>nil</code> 而<strong>不仅仅是对象类型</strong>。</p>
<h4 id="If-语句以及强制展开"><a href="#If-语句以及强制展开" class="headerlink" title="If 语句以及强制展开"></a>If 语句以及强制展开</h4><p>你可以利用 <code>if</code> 语句通过比较 <code>nil</code> 来判断一个可选中是否包含值。利用相等运算符 <code>（ == ）</code>和不等运算符<code>（ != ）</code>。<br>如果一个可选有值，他就“不等于” <code>nil</code>，一旦你确定可选中包含值，你可以在可选的名字后面加一个感叹号 <code>（ ! ）</code> 来获取值，感叹号的意思就是说“我知道这个可选项里边有值，展开吧。”这就是所谓的可选值的强制展开。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber contains some integer value."</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber has an integer value of <span class="subst">\(convertedNumber!)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints "convertedNumber contains some integer value."</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>使用 <code>!</code> 来获取一个不存在的可选值会导致运行错误，在使用!强制展开之前必须确保可选项中包含一个非 <code>nil</code> 的值。</p>
<h4 id="可选项绑定"><a href="#可选项绑定" class="headerlink" title="可选项绑定"></a>可选项绑定</h4><p>可以使用<em>可选项绑定</em>来判断<strong>可选项</strong>是否包含值，如果包含就把值赋给一个<strong>临时的常量或者变量</strong>。可选绑定可以与 <code>if</code> 和 <code>while</code> 的语句使用来检查可选项内部的值，并赋值给一个变量或常量。</p>
<p>在 <code>if</code> 语句中，这样书写可选绑定：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber = <span class="type">Int</span>(possibleNumber) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\'<span class="subst">\(possibleNumber)</span>\' has an integer value of <span class="subst">\(actualNumber)</span>"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\'<span class="subst">\(possibleNumber)</span>\' could not be converted to an integer"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints '123' has an integr value of 123</span></div></pre></td></tr></table></figure>
<p>如果转换成功，常量 <code>actualNumber</code> 就可以用在 <code>if</code> 语句的第一个分支中，他早已被可选内部的值进行了初始化，所以这时就没有必要用 <code>!</code> 后缀来获取里边的值。在这个栗子中 <code>actualNumber</code> 被用来输出转换后的值。</p>
<p><em>常量</em>和<em>变量</em>都可以使用可选项绑定，如果你想操作 <code>if</code> 语句中第一个分支的 <code>actualNumber</code> 的值，你可以写 if var actualNumber 来代替，可选项内部包含的值就会被设置为一个变量而不是常量。</p>
<p><strong>你可以在同一个 <code>if</code> 语句中包含多可选项绑定，用逗号分隔即可。如果任一可选绑定结果是 <code>nil</code> 或者布尔值**</strong>为 <code>false</code> ，那么整个 <code>if</code> 判断会被看作 <code>false</code> 。下面的两个 <code>if</code> 语句是等价的：**</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber = <span class="type">Int</span>(<span class="string">"4"</span>), <span class="keyword">let</span> secondNumber = <span class="type">Int</span>(<span class="string">"42"</span>), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; <span class="number">100</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100"</span>)<span class="comment">//prints "4 &lt; 42 &lt; 100"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber = <span class="type">Int</span>(<span class="string">"4"</span>) &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> secondNumber = <span class="type">Int</span>(<span class="string">"42"</span>) &#123;</div><div class="line">        <span class="keyword">if</span> firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; <span class="number">100</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100"</span>)<span class="comment">//prints "4 &lt; 42 &lt; 100"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>使用 <code>if</code> 语句创建的常量和变量只在<strong><code>if</code>语句的函数体内有效</strong>。相反，在 <code>guard</code> 语句中创建的常量和变量在 <code>guard</code> <strong>语句后的代码中也可用</strong>。</p>
<h4 id="隐式展开可选项"><a href="#隐式展开可选项" class="headerlink" title="隐式展开可选项"></a>隐式展开可选项</h4><p><strong>可选项</strong>明确了常量或者变量可以“没有值”。可选项可以通过 if 语句来判断是否有值，如果有值的话可以通过可选项绑定来获取里边的值。</p>
<p>有时在一些程序结构中可选项一旦被设定值之后，就会一直拥有值。在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行展开，因为它可以安全的确认每次访问的时候都有一个值。</p>
<p>这种类型的可选项被定义为<strong>隐式展开可选项</strong>。通过在<strong>声明的类型后</strong>边添加一个<strong>叹号</strong><code>（ String! ）</code>而非问号<code>（  String? ）</code> 来书写<strong>隐式展开可选项</strong>。在可选项被定义的时候就能立即确认其中有值的情况下，隐式展开可选项非常有用，<strong>隐式展开可选项</strong>主要被用在 <code>Swift</code> 类的初始化过程中。</p>
<p><strong>隐式展开可选项</strong>是后台场景中通用的可选项， <em>但是同样可以像非可选值那样来使用，</em> 每次访问的时候都不需要展开。下面的栗子展示了在访问被明确为 <code>String</code>  的可选项展开值时，可选字符串和隐式展开可选字符串的行为区别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? = <span class="string">"An optional string."</span> <span class="comment">//可选项</span></div><div class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> = possibleString!</div><div class="line"></div><div class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! = <span class="string">"An implicitly unwrapped optional string."</span> <span class="comment">//隐式可选项</span></div><div class="line"><span class="keyword">let</span> implicitString: <span class="type">String</span> = assumedString</div></pre></td></tr></table></figure>
<p>你可以把<strong>隐式展开可选项</strong>当做在每次访问它的时候被给予了 <em>自动进行展开的权限</em> ，你可以在声明可选项的时候添加一个叹号而不是每次调用的时候在可选项后边添加一个叹号。</p>
<p><strong>注意：</strong>如果你在隐式展开可选项没有值的时候还尝试获取值，会导致运行错误。结果和在没有值的普通可选项后面加一个叹号一样。<code>string!</code></p>
<p>你可以像对待普通可选一样对待隐式展开可选项来检查里边是否包含一个值，你也可以使用隐式展开可选项通过可选项绑定在一句话中检查和展开值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> assumedString != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="built_in">print</span>(assumedString)</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> definiteString = assumedString &#123;</div><div class="line">    <span class="built_in">print</span>(definiteString)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不要在一个变量将来会变为 <code>nil</code> 的情况下使用隐式展开可选项。如果你需要检查一个变量在生存期内是否会变为 <code>nil</code> ，就使用普通的可选项。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在程序执行阶段，你可以使用错误处理机制来为错误状况负责。相比于可选项的通过值是否缺失来判断程序的执行正确与否， <em>而错误处理机制能允许你判断错误的形成原因</em> ，在必要的情况下，还能将你的代码中的错误<strong>传递</strong>到程序的其他地方。</p>
<p>当一个函数遇到错误情况，他会抛出一个错误，这个函数的访问者会捕捉到这个错误，并作出合适的反应。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">canThrowAnError</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</div><div class="line">    <span class="comment">// this function may or may not throw an error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过在函数声明过程当中加入 <code>throws</code> 关键字来表明这个函数会抛出一个错误。当你调用了一个可以抛出错误的函数时，需要在表达式前预置 <code>try</code> 关键字。<br><code>Swift</code> 会自动将错误传递到它们的生效范围之外，直到它们被 <code>catch</code> 分句处理。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">try</span> canThrowAnError()</div><div class="line">    <span class="comment">// no error was thrown</span></div><div class="line">&#125; <span class="keyword">catch</span> &#123;</div><div class="line">    <span class="comment">//an error was thrown</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>do</code> 语句创建了一个新的容器范围，可以让错误被传递到到不止一个的 <code>catch</code> 分句里。<br>下面的栗子演示了如何利用错误处理机制处理不同的错误情况：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeASandwich</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">try</span> makeASandwich()</div><div class="line">    eatASandwich()</div><div class="line">&#125; <span class="keyword">catch</span> <span class="type">Error</span>.<span class="type">OutOfCleanDishes</span> &#123;</div><div class="line">    washDishes()</div><div class="line">&#125; <span class="keyword">catch</span> <span class="type">Error</span>.<span class="type">MissingIngredients</span>(<span class="keyword">let</span> ingredients) &#123;</div><div class="line">    buyGroceries(ingredients)</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  在上面的栗子中，在没有干净的盘子或者缺少原料的情况下，方法 makeASandwich()</span></div><div class="line"><span class="comment">  就会抛出一个错误。由于 makeASandwich() 的抛出，</span></div><div class="line"><span class="comment">  方法的调用被包裹在了一个 try 的表达式中。通过将方法的调用包裹在 do 语句中，</span></div><div class="line"><span class="comment">  任何抛出来的错误都会被传递到预先提供的 catch 分句中。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">如果没有错误抛出，方法 eatASandwich() 就会被调用，</span></div><div class="line"><span class="comment">如果有错误抛出且满足 Error.OutOfCleanDishes 这个条件，</span></div><div class="line"><span class="comment">方法 washDishes() 就会被执行。如果一个错误被抛出，</span></div><div class="line"><span class="comment">而它又满足 Error.MissingIngredients 的条件，那么 buyGroceries(_:) </span></div><div class="line"><span class="comment">就会协同被 catch 模式捕获的  [String] 值一起调用。</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure>
<h3 id="断言和先决条件"><a href="#断言和先决条件" class="headerlink" title="断言和先决条件"></a>断言和先决条件</h3><p><strong>断言</strong>和<strong>先决条件</strong>用来检测运行时发生的事情。你可以使用它们来保证在执行后续代码前某必要条件是满足的。如果布尔条件在断言或先决条件中计算为 <code>true</code> ，代码就正常继续执行。如果条件计算为 false ，那么程序当前的状态就是非法的；代码执行结束，然后你的 <code>app</code> 终止。</p>
<p><strong>断言</strong>和<strong>先决条件</strong>的不同之处在于他们什么时候做检查：<em>断言</em>只在 <code>debug</code> 构建的时候检查，但<em>先决条件</em>则在 <code>debug</code> 和生产构建中生效。在生产构建中，断言中的条件不会被计算。这就是说你可以在开发的过程当中随便使用断言而无需担心影响生产性能。</p>
<h4 id="使用断言进行调试"><a href="#使用断言进行调试" class="headerlink" title="使用断言进行调试"></a>使用断言进行调试</h4><p>断言会在运行的时候检查一个逻辑条件是否为 <code>true</code> 。顾名思义，断言可以“<em>断言</em>”一个条件是否为真。你可以使用断言确保在运行其他代码之前必要的条件已经被满足。如果条件判断为 <code>true</code>，代码运行会继续进行；如果条件判断为 <code>false</code>，代码运行结束，你的应用也就中止了。</p>
<p>如果你的代码在调试环境下触发了一个断言，例如你在 Xcode 中创建并运行一个应用，你可以明确的知道不可用的状态发生在什么地方，还能检查断言被触发时你的应用的状态。另外，断言还允许你附加一条调试的信息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> age = -<span class="number">3</span></div><div class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>, <span class="string">"A person`s age cannot be less than zero."</span>)</div><div class="line"><span class="comment">//also like this</span></div><div class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>在这个例子当中，代码执行只要在 <code>if age &gt;= 0</code> 评定为 <code>true</code> 时才会继续，就是说，如果 <code>age</code> 的值非负。如果 <code>age</code> 的值是负数，在上文的代码当中， <code>age &gt;= 0</code> 评定为 <code>false</code> ，断言就会被触发，终止应用。</p>
<p>如果代码<strong>已经检查了条件</strong>，你可以使用 <code>assertionFailure(_:file:line:)</code> 函数来<strong>标明断言失败</strong>，比如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> age &gt; <span class="number">10</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"You can ride the roller-coaster or the ferris wheel."</span>)</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> age &gt; <span class="number">0</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"You can ride the ferris wheel."</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">assertionFailure</span>(<span class="string">"A person`s age can`t be less than zero."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="强制先决条件"><a href="#强制先决条件" class="headerlink" title="强制先决条件"></a>强制先决条件</h4><p>在你代码中任何条件<strong>可能潜在为假</strong>但必须肯定<strong>为真</strong>才能继续执行的地方使用<code>先决条件</code>。比如说，使用先决条件来检测下标没有越界，或者检测函数是否收到了一个合法的值。</p>
<p>你可以通过调用 <code>precondition(_:_:file:line:)</code> 函数来写先决条件。给这个函数传入表达式计算为 <code>true</code> 或 <code>false</code> ，如果条件的结果是 <code>false</code> 信息就会显示出来。比如说：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In the implementation of a subscript...</span></div><div class="line"><span class="built_in">precondition</span>(index &gt; <span class="number">0</span>, <span class="string">"Index must be greater than zero."</span>)</div></pre></td></tr></table></figure>
<p>注意：<br>如果你在<strong>不检查模式</strong>编译<code>（ -Ounchecked ）</code>，先决条件不会检查。编译器假定先决条件永远为真，并且它根据你的代码进行优化。总之， <code>fatalError(_:file:line:)</code> 函数一定会终止执行，无论你优化设定如何。</p>
<p>你可以在草拟和早期开发过程中使用 <code>fatalError(_:file:line:)</code>函数标记那些还没实现的功能，通过使用 <code>fatalError(&quot;Unimplemented&quot;)</code>来作为代替。由于致命错误永远不会被优化，不同于断言和先决条件，你可以确定执行遇到这些临时占位永远会停止。</p>
<blockquote>
<p>摘自：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" target="_blank" rel="external">swift 官网</a><br>所有代码在Xcode9 Swift4 环境编译没问题，代码<a href="https://github.com/keshiim/LearnSwift4" target="_blank" rel="external">戳这里 https://github.com/keshiim/LearnSwift4</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keshiim.github.io/2017/10/20/Swift prev/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng keshiim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Farmer, keshiim 播种太阳🌞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/20/Swift prev/" itemprop="url">Swift：初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-20T18:30:00+08:00">
                2017-10-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/20/Swift prev/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/20/Swift prev/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/10/20/Swift prev/" class="leancloud_visitors" data-flag-title="Swift：初探">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自从swift流行起来之后，一直没有认真学习过Swift，还是杀下心来按照Swift AppleDoc系统学习一次。依照传统，先用Swift在屏幕上打印“Hellow, world!”</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"Hello, world!"</span>)</div></pre></td></tr></table></figure>
<p>如果你曾使用 C 或者 Objective-C 写代码，那么 Swift 的语法不会让你感到陌生——在 Swift 语言当中，这一行代码就是一个完整的程序！你不需要为每一个功能导入单独的库比如输入输出和字符串处理功能。写在全局范围的代码已被用来作为程序的入口，所以你不再需要 <code>main()</code>函数。同样，你也不再需要在每句代码后边写分号。</p>
<h3 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h3><p>使用 <code>let</code>来声明一个常量，用 <code>var</code>来声明一个变量。常量的值在编译时并不要求已知，但是你必须为其赋值一次。这意味着你可以使用常量来给一个值命名，然后一次定义多次使用。</p>
<p>不需要总是显式地写出类型，在声明一个常量或者变量的时候直接给它们赋值就可以让编译器推断它们的类型。如果初始值并不能提供足够的信息（或者根本没有提供初始值），就需要在变量的后边写出来了，用冒号分隔。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> implicitInteger = <span class="number">70</span></div><div class="line"><span class="keyword">let</span> implicitDouble = <span class="number">70.0</span></div><div class="line"><span class="keyword">let</span> explicitDouble: <span class="type">Double</span> = <span class="number">70</span></div></pre></td></tr></table></figure>
<p>值绝对不会隐式地转换为其他类型。如果你需要将一个值转换为不同的类型，需要使用对应的类型显示地声明。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> label = <span class="string">"The width is "</span></div><div class="line"><span class="keyword">let</span> width = <span class="number">94</span></div><div class="line"><span class="keyword">let</span> widthLabel = label + <span class="type">String</span>(width)</div></pre></td></tr></table></figure>
<p>其实还有一种更简单的方法来把值加入字符串：将值写在圆括号里，然后再在圆括号的前边写一个反斜杠 （ \） ，举个栗子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> apples = <span class="number">3</span></div><div class="line"><span class="keyword">let</span> oranges = <span class="number">5</span></div><div class="line"><span class="keyword">let</span> appleSummary = <span class="string">"I have <span class="subst">\(apples)</span> apples."</span></div><div class="line"><span class="keyword">let</span> fruitSummary = <span class="string">"I have <span class="subst">\(apples + oranges)</span> pieces of fruit."</span></div></pre></td></tr></table></figure>
<p>使用方括号（ []）来创建数组或者字典，并且使用方括号来按照序号或者键访问它们的元素。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"catfish"</span>, <span class="string">"water"</span>, <span class="string">"tulips"</span>, <span class="string">"blue paint"</span>]</div><div class="line">shoppingList[<span class="number">1</span>] = <span class="string">"bottle of water"</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> occupations = [</div><div class="line">    <span class="string">"Malcolm"</span>: <span class="string">"Captain"</span>,</div><div class="line">    <span class="string">"Kaylee"</span>: <span class="string">"Mechanic"</span>,</div><div class="line">]</div><div class="line">occupations[<span class="string">"Jayne"</span>] = <span class="string">"Public Relations"</span></div></pre></td></tr></table></figure>
<p>数组和字典可以有两种初始化方式分别如下:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方式一 - 显示声明</span></div><div class="line"><span class="keyword">let</span> emptyArray = [<span class="type">String</span>]()</div><div class="line"><span class="keyword">let</span> emptyDictionary = [<span class="type">String</span>: <span class="type">Float</span>]()</div><div class="line"></div><div class="line"><span class="comment">//方式二 - 隐式</span></div><div class="line">shoppingList = []</div><div class="line">occupations = [:]</div></pre></td></tr></table></figure>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>使用 <code>if</code>和 <code>switch</code>来做逻辑判断，使用 <code>for-in</code>， <code>for</code>， <code>while</code>，以及 <code>repeat-while</code>来做循环，不在强制使用圆括号，但仍旧需要使用花括号来括住代码块。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> individualScores = [<span class="number">75</span>, <span class="number">43</span>, <span class="number">103</span>, <span class="number">87</span>, <span class="number">12</span>]</div><div class="line"><span class="keyword">var</span> teamScore = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> score <span class="keyword">in</span> individualScores &#123;</div><div class="line">    <span class="keyword">if</span> score &gt; <span class="number">50</span> &#123;</div><div class="line">        teamScore += <span class="number">3</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        teamScore += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(teamScore)</div></pre></td></tr></table></figure>
<p>if语句当中，<strong>条件必须是布尔表达式</strong>，注意和Objective-C的区别。<br>当然要达到Objective-C的<code>if</code>可判断布尔表达式和真假值，你可以一起使用 <code>if</code>和 <code>let</code>来操作那些可能会丢失的值。这些值使用可选项表示。可选的值包括了一个值或者一个 nil来表示值不存在。在一个值的类型后边使用问号（ ?）来把某个值标记为可选的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> v = optionValue &#123;</div><div class="line">    <span class="comment">//使用v</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//v 为 nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果可选项的值为 <code>nil</code>，则条件为 <code>false</code>并且花括号里的代码将会被跳过。否则，可选项的值就会被展开且赋给 let后边声明的常量，这样会让展开的值对花括号内的代码可用。</p>
<p>高级用法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span> name = json[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</div><div class="line">      <span class="keyword">let</span> coordinatesJSON = json[<span class="string">"coordinates"</span>] <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Double</span>],</div><div class="line">      <span class="keyword">let</span> latitude = coordinatesJSON[<span class="string">"lat"</span>], </div><div class="line">      <span class="keyword">let</span> longitude = coordinatesJSON[<span class="string">"lng"</span>], </div><div class="line">      <span class="keyword">let</span> mealsJSON = json[<span class="string">"meals"</span>] <span class="keyword">as</span>? [<span class="type">String</span>] <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一种处理可选值的方法是使用 <code>??</code> 运算符提供默认值。如果可选值丢失，默认值就会使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> nickName: <span class="type">String</span>? = <span class="literal">nil</span></div><div class="line"><span class="keyword">let</span> informalGreeting = <span class="string">"Hi <span class="subst">\(nickName ?? "You")</span>"</span></div></pre></td></tr></table></figure>
<p>Switch 选择语句支持任意类型的数据和各种类型的比较操作——它不再限制于整型和测试相等上。在执行完 switch 语句里匹配到的 case 之后，程序就会从 switch 语句中退出。执行并不会继续跳到下一个 case 里，所以完全没有必要显式地在每一个 case 后都标记 break 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vegetable: <span class="type">String</span> = <span class="string">"red pepper"</span></div><div class="line"><span class="keyword">switch</span> vegetable &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">"celery"</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Add come raisions and make ants on a log."</span>)</div><div class="line"><span class="keyword">case</span> <span class="string">"cucumber"</span>, <span class="string">"watercress"</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"That would make a good tea sandwich."</span>)</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> y <span class="keyword">where</span> y.hasPrefix(<span class="string">"red"</span>) :</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(y)</span>&lt;&lt;&lt;"</span>)</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">"pepper"</span>):</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Is it a spicy <span class="subst">\(x)</span>?"</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Everything tastes good in soup."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意</strong> <code>let</code> <strong>可以用在模式里来指定匹配的值到一个常量当中</strong>。</p>
<!--new for -in -->
<p>你可以使用 for-in来遍历字典中的项目，这需要提供一对变量名来储存键值对。字典使用无序集合，所以键值的遍历也是无序的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> interestingNumbers = [</div><div class="line">    <span class="string">"Prime"</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>],</div><div class="line">    <span class="string">"Fibonacci"</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>],</div><div class="line">    <span class="string">"Square"</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>],</div><div class="line">]</div><div class="line"><span class="keyword">var</span> largest = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> (key, numbers) <span class="keyword">in</span> interestingNumbers &#123;</div><div class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</div><div class="line">        largest = number &gt; largest ? number : largest</div><div class="line"><span class="comment">//        if number &gt; largest &#123;</span></div><div class="line"><span class="comment">//            largest = number</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"largest = <span class="subst">\(largest)</span>"</span>)</div></pre></td></tr></table></figure>
<p>使用 while来重复代码快直到条件改变。循环的条件可以放在末尾，这样可以保证循环至少运行了一次。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n = <span class="number">2</span></div><div class="line"><span class="keyword">while</span> n &lt; <span class="number">100</span> &#123;</div><div class="line">    n = n * <span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(n)</div><div class="line"></div><div class="line"><span class="keyword">repeat</span> &#123;</div><div class="line">    m = m * <span class="number">2</span></div><div class="line">&#125; <span class="keyword">while</span> m &lt; <span class="number">100</span></div><div class="line"><span class="built_in">print</span>(m)</div></pre></td></tr></table></figure>
<p>使用 ..&lt;来创建一个不包含最大值的区间，使用 … 来创造一个包含最大值和最小值的区间。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> total = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">4</span> &#123;</div><div class="line">    total += i</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(total)</div></pre></td></tr></table></figure>
<h3 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h3><p>使用 <code>func</code>来声明一个函数。通过在名字之后在圆括号内添加一系列参数来调用这个方法。使用 -&gt;来分隔形式参数名字类型和函数返回的类型。<br>默认情况下，函数使用他们的形式参数名来作为实际参数标签。在形式参数前可以写自定义的实际参数标签，或者使用 _ 来避免使用实际参数标签。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> person: String, on day: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello <span class="subst">\(person)</span>, today is <span class="subst">\(day)</span>."</span></div><div class="line">&#125;</div><div class="line">greet(person: <span class="string">"keshiim"</span>, on: <span class="string">"Thursday"</span>)</div></pre></td></tr></table></figure>
<p>使用元组来创建复合值——比如，为了从函数中返回多个值。元组中的元素可以通过名字或者数字调用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateStatistics</span><span class="params">(scores: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>, sum: <span class="type">Int</span>) &#123;</div><div class="line">    <span class="keyword">var</span> <span class="built_in">min</span> = scores[<span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> <span class="built_in">max</span> = scores[<span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> score <span class="keyword">in</span> scores &#123;</div><div class="line">        <span class="keyword">if</span> score &gt; <span class="built_in">max</span> &#123;</div><div class="line">            <span class="built_in">max</span> = score</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> score &lt; <span class="built_in">min</span> &#123;</div><div class="line">            <span class="built_in">min</span> = score</div><div class="line">        &#125;</div><div class="line">        sum += score</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> (<span class="built_in">min</span>, <span class="built_in">max</span>, sum)</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> statistics = calculateStatistics(scores: [<span class="number">5</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">9</span>])</div><div class="line"><span class="built_in">print</span>(statistics.sum)</div><div class="line"><span class="built_in">print</span>(statistics.<span class="number">2</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：返回值元素取成员可直接用成员名称，也可以用以元素成员从下标为0顺序的取值例如<code>statistics.2</code></p>
</blockquote>
<p>函数同样可以接受多个参数，然后把它们存放进数组当中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOf</span><span class="params">(numbers: Int...)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</div><div class="line">        sum += number</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum</div><div class="line">&#125;</div><div class="line">sumOf()</div><div class="line">sumOf(numbers: <span class="number">42</span>, <span class="number">597</span>, <span class="number">12</span>)</div></pre></td></tr></table></figure>
<p>函数可以内嵌。<strong>内嵌的函数</strong>可以访问外部函数里的变量。你可以通过使用内嵌函数来组织代码，以避免某个函数太长或者太过复杂。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnFifteen</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">var</span> y = <span class="number">10</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</div><div class="line">        y += <span class="number">5</span></div><div class="line">    &#125;</div><div class="line">    add()</div><div class="line">    <span class="keyword">return</span> y</div><div class="line">&#125;</div><div class="line">returnFifteen()</div></pre></td></tr></table></figure>
<p>同时，函数是一等类型，这意味着函数可以把函数作为值来返回。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeincrementer</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> + number</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> addOne</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> increment = makeincrementer()</div><div class="line">increment(<span class="number">7</span>)</div></pre></td></tr></table></figure>
<p>函数也可以把另外一个函数作为其自身的参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasAnyMatchs</span><span class="params">(list: [Int], condition: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</div><div class="line">        <span class="keyword">if</span> condition(item) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">lessThanTen</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> number &lt; <span class="number">10</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">20</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">12</span>];</div><div class="line">hasAnyMatchs(list: numbers, condition: lessThanTen)</div></pre></td></tr></table></figure>
<p><strong>闭包：</strong>函数其实就是闭包的一种特殊形式：一段可以被随后调用的代码块。闭包中的代码可以访问其生效范围内的变量和函数，就算是闭包在它声明的范围之外被执行——你已经在内嵌函数的栗子上感受过了。你可以使用花括号<code>（{ }）</code>括起一个没有名字的闭包。在闭包中使用 <code>in</code>来分隔<strong>实际参数</strong>和<strong>返回类型</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//例子中将[Int]类型数组中每个值x2转成Sting类型，返回数组</span></div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">20</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">12</span>];</div><div class="line"><span class="built_in">print</span>(numbers.<span class="built_in">map</span> &#123; (number: <span class="type">Int</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">let</span> result  = <span class="number">2</span> * number</div><div class="line">    <span class="keyword">return</span> <span class="type">String</span>(result)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>你有更多的选择来把闭包写的更加简洁。当一个闭包的类型已经可知，比如说某个委托的回调，你可以去掉它的<strong>参数类型</strong>，它的<strong>返回类型</strong>，或者都去掉。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> mappedNumbers = numbers.<span class="built_in">map</span>(&#123; number <span class="keyword">in</span> <span class="number">3</span> * number &#125;)</div><div class="line"><span class="built_in">print</span>(mappedNumbers)</div></pre></td></tr></table></figure>
<p>你可以调用参数通过数字而非名字——这个特性在非常简短的闭包当中尤其有用。<strong>当一个闭包作为函数最后一个参数出入时，可以直接跟在圆括号后边。如果闭包是函数的唯一参数，你可以去掉圆括号直接写闭包</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sortedNumbers = numbers.sorted &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</div><div class="line"><span class="built_in">print</span>(sortedNumbers)</div></pre></td></tr></table></figure>
<h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h3><p>通过在<code>class</code>后接类名称来创建一个类。在类里边声明属性与声明常量或者变量的方法是相同的，唯一的区别的它们在类环境下。同样的，方法和函数的声明也是相同的写法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> numberOfSides = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"A Shape with <span class="subst">\(numberOfSides)</span> sides."</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>通过在类名字后边添加一对圆括号来创建一个类的实例</strong>。使用<strong>点语法</strong>来访问实例里的属性和方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shape = <span class="type">Shape</span>()</div><div class="line">shape.numberOfSides = <span class="number">4</span></div><div class="line">shape.simpleDescription()</div></pre></td></tr></table></figure>
<p>为<code>Shape</code>类的添加一个重要的东西：一个用在创建实例的时候来设置类的初始化器。使用 init来创建一个初始化器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedShape</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> numberOfSides: <span class="type">Int</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"A shape with <span class="subst">\(numberOfSides)</span> sides."</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意使用 <code>self</code>来区分 <code>name</code>属性还是初始化器里的 <code>name</code>参数。创建类实例的时候给初始化器传参就好像是调用方法一样。每一个<strong>属性都需要赋值</strong>——<em>要么在声明的时候</em>（比如说 <code>numberOfSides</code>），<em>要么就要在初始化器里赋值</em>（比如说 name），使用 <code>deinit</code>来创建一个反初始化器，如果你需要在释放对象之前执行一些清理工作的话。</p>
<p>子类的方法如果要重写父类的实现，则需要使用 <code>override</code>——不使用 <code>override</code>关键字来标记则会导致编译器报错。编译器同样也会检测使用 <code>override</code>的方法是否存在于父类当中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>: <span class="title">NamedShape</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span></div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.sideLength = sideLength</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</div><div class="line">        numberOfSides = <span class="number">4</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">()</span></span> -&gt;  <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">return</span> sideLength * sideLength</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"A square with sides of length <span class="subst">\(sideLength)</span>."</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> test = <span class="type">Square</span>(sideLength: <span class="number">5.2</span>, name: <span class="string">"my test square"</span>)</div><div class="line">test.area()</div><div class="line">test.simpleDescription()</div></pre></td></tr></table></figure>
<p>除了存储属性，你也可以拥有带有 getter 和 setter 的计算属性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">equilateralTriangle</span>: <span class="title">NamedShape</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span> = <span class="number">0.0</span></div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.sideLength = sideLength</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</div><div class="line">        numberOfSides = <span class="number">3</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">3.0</span> * sideLength</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            sideLength = newValue / <span class="number">3.0</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"An equilateral triangle with sides of length <span class="subst">\(sideLength)</span>."</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> triangle = equilateralTriangle(sideLength: <span class="number">3.1</span>, name: <span class="string">"a triangle"</span>)</div><div class="line"><span class="built_in">print</span>(triangle.perimeter)</div><div class="line">triangle.perimeter = <span class="number">9.9</span></div><div class="line"><span class="built_in">print</span>(triangle.sideLength)</div></pre></td></tr></table></figure>
<p>在 <code>perimeter</code>的 <code>setter</code> 中，新值被<strong>隐式地</strong>命名为 <code>newValue</code>。你可以提供一个显式的名字放在 <code>set</code> 后边的<strong>圆括号</strong>里。</p>
<p>设置一个新值的前后执行代码，使用 <code>willSet</code>和 <code>didSet</code>。比如说，下面的类确保三角形的边长始终和正方形的边长相同.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TriangleAndSquare</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> triangle: <span class="type">EquilateralTriangle</span> &#123;</div><div class="line">        <span class="keyword">willSet</span> &#123;</div><div class="line">            square.sideLength = newValue.sideLength</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> square: <span class="type">Square</span> &#123;</div><div class="line">        <span class="keyword">willSet</span> &#123;</div><div class="line">            triangle.sideLength = newValue.sideLength</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">init</span>(size: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</div><div class="line">        square = <span class="type">Square</span>(sideLength: size, name: name)</div><div class="line">        triangle = <span class="type">EquilateralTriangle</span>(sideLength: size, name: name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> triangleAndSquare = <span class="type">TriangleAndSquare</span>(size: <span class="number">10</span>, name: <span class="string">"another test shape"</span>)</div><div class="line"><span class="built_in">print</span>(triangleAndSquare.square.sideLength)</div><div class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</div><div class="line">triangleAndSquare.square = <span class="type">Square</span>(sideLength: <span class="number">50</span>, name: <span class="string">"large square"</span>)</div><div class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</div></pre></td></tr></table></figure>
<p>当你操作可选项的值的时候，你可以在可选值后边使用 <code>?</code>比如方法，属性和下标脚本。如果 <code>?</code>前的值是 <code>nil</code>，那 <code>?</code>后的所有内容都会被忽略并且整个表达式的值都是 <code>nil</code>。否则，可选项的值将被展开，然后 <code>?</code>后边的代码根据展开的值执行。在这两种情况当中，表达式的值是一个可选的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> optionalSquare: <span class="type">Square</span>? = <span class="type">Square</span>(sideLength: <span class="number">2.5</span>, name: <span class="string">"optional square"</span>)</div><div class="line"><span class="keyword">let</span> sideLength = optionalSquare?.sideLength</div></pre></td></tr></table></figure>
<h3 id="枚举和结构体"><a href="#枚举和结构体" class="headerlink" title="枚举和结构体"></a>枚举和结构体</h3><p>使用 <code>enum</code>来创建枚举，类似于类和其他所有的命名类型，枚举也能够包含方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> ace = <span class="number">1</span></div><div class="line">    <span class="keyword">case</span> two, three, four, five, six, seven, eight, nine, ten</div><div class="line">    <span class="keyword">case</span> jack, queen, king</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">        <span class="keyword">case</span> .ace:</div><div class="line">            <span class="keyword">return</span> <span class="string">"ace"</span></div><div class="line">        <span class="keyword">case</span> .jack:</div><div class="line">            <span class="keyword">return</span> <span class="string">"jack"</span></div><div class="line">        <span class="keyword">case</span> .queen:</div><div class="line">            <span class="keyword">return</span> <span class="string">"queen"</span></div><div class="line">        <span class="keyword">case</span> .king:</div><div class="line">            <span class="keyword">return</span> <span class="string">"king"</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>.rawValue)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> ace = <span class="type">Rank</span>.ace</div><div class="line"><span class="keyword">let</span> aceRowValue = ace.rawValue</div></pre></td></tr></table></figure>
<p>默认情况下，Swift 从零开始给原始值赋值后边递增，但你可以通过指定特定的值来改变这一行为。在上边的栗子当中，原始值的枚举类型是 Int，所以你只需要确定第一个原始值。剩下的原始值是按照顺序指定的。你同样可以使用字符串或者浮点数作为枚举的原始值。使用 rawValue 属性来访问枚举成员的原始值。</p>
<p>使用 init?(rawValue:) 初始化器来从一个原始值创建枚举的实例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> convertRank = <span class="type">Rank</span>(rawValue: <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">let</span> aceDescription = convertRank.simpleDescription()</div><div class="line">    <span class="built_in">print</span>(aceDescription)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>枚举成员的<strong>值是实际的值，不是原始值的另一种写法</strong>。事实上，在这种情况下没有一个有意义的原始值，你根本没有必要提供一个。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suite</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> spades, hearts, diamonds, clubs</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">        <span class="keyword">case</span> .spades:</div><div class="line">            <span class="keyword">return</span> <span class="string">"spades"</span></div><div class="line">        <span class="keyword">case</span> .hearts:</div><div class="line">            <span class="keyword">return</span> <span class="string">"hearts"</span></div><div class="line">        <span class="keyword">case</span> .diamonds:</div><div class="line">            <span class="keyword">return</span> <span class="string">"diamonds"</span></div><div class="line">        <span class="keyword">case</span> .clubs:</div><div class="line">            <span class="keyword">return</span> <span class="string">"clubs"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">color</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">        <span class="keyword">case</span> .spades, .clubs:</div><div class="line">            <span class="keyword">return</span> <span class="string">"black"</span></div><div class="line">        <span class="keyword">case</span> .hearts, .diamonds:</div><div class="line">            <span class="keyword">return</span> <span class="string">"red"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> hearts = <span class="type">Suite</span>.hearts</div><div class="line">hearts.simpleDescription()</div><div class="line">hearts.color()</div></pre></td></tr></table></figure>
<p>注意有两种方法可以调用枚举的 <code>hearts</code>成员：当给 <code>hearts</code>指定一个常量时，枚举成员 <code>Suit.Hearts</code>会被以全名的方式调用因为常量并没有显式地指定类型。在 <code>Switch</code> 语句当中，枚举成员可以通过缩写的方式 <code>.hearts</code>被调用，因为 <code>self</code>已经明确了是 <code>suit</code>。<strong><em>总之你可以在任何值的类型已经明确的场景下使用使用缩写。</em></strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> heartss: <span class="type">Suite</span> = .hearts</div><div class="line">heartss.simpleDescription()</div></pre></td></tr></table></figure>
<p><em><code>enum</code>高阶用法</em>：如果枚举拥有<strong>原始值</strong>，这些值在<strong>声明时确定</strong>，就是说每一个这个枚举的<strong>实例</strong>都将拥有<strong>相同的原始值</strong>。另一个选择是让<strong>case与值关联</strong>——这些值在你<strong>初始化实例的时候确定</strong>，这样它们就可以在<strong>每个实例中不同</strong>了。比如说，考虑在服务器上请求日出和日落时间的case，服务器要么返回请求的信息，要么返回错误信息。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ServerResponse</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> result(<span class="type">String</span>, <span class="type">String</span>)</div><div class="line">    <span class="keyword">case</span> failure(<span class="type">String</span>)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .result(sunrise, sunset):</div><div class="line">            <span class="keyword">return</span> <span class="string">"Sunrise is at <span class="subst">\(sunrise)</span> and sunset is at<span class="subst">\(sunset)</span>"</span></div><div class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .failure(message):</div><div class="line">            <span class="keyword">return</span> <span class="string">"Failure:.. <span class="subst">\(message)</span>"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> success = <span class="type">ServerResponse</span>.result(<span class="string">"6:0 am"</span>, <span class="string">"8:0 pm"</span>)</div><div class="line"><span class="keyword">let</span> failure = <span class="type">ServerResponse</span>.failure(<span class="string">"Out of cheese."</span>)</div><div class="line">success.simpleDescription()</div><div class="line">failure.simpleDescription()</div></pre></td></tr></table></figure>
<p>注意现在日出和日落时间是从 <code>ServerResponse</code> 值中以<code>switch case</code> <strong>匹配的形</strong>式取出的</p>
<p>使用 <code>struct</code>来创建结构体。结构体提供很多类似与类的行为，包括方法和初始化器。其中最重要的一点区别就是结构体总是会在传递的时候拷贝其<strong>自身</strong>(<strong>传值</strong>)，而类则会传递<strong>引用</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> rank: <span class="type">Rank</span></div><div class="line">    <span class="keyword">var</span> suit: <span class="type">Suite</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDecription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"The <span class="subst">\(rank.simpleDescription()</span>) of <span class="subst">\(suit.simpleDescription()</span>)"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> threeOfSpades = <span class="type">Card</span>(rank: .three, suit: .spades)</div><div class="line"><span class="keyword">let</span> threeOfSpadesDescription = threeOfSpades.simpleDecription()</div></pre></td></tr></table></figure>
<h3 id="协议和扩展"><a href="#协议和扩展" class="headerlink" title="协议和扩展"></a>协议和扩展</h3><p>使用 <code>protocol</code>来声明协议。<strong>类</strong>，<strong>枚举</strong>以及<strong>结构体</strong>都兼容协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//protocol</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ExampleProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"><span class="comment">//class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span>: <span class="title">ExampleProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">"A very simle class."</span></div><div class="line">    <span class="keyword">var</span> anotherProperty: <span class="type">Int</span> = <span class="number">6999</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</div><div class="line">        simpleDescription += <span class="string">" Now 100% adjueted."</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="type">SimpleClass</span>()</div><div class="line">a.adjust()</div><div class="line"><span class="keyword">let</span> aDescription = a.simpleDescription</div><div class="line"><span class="comment">//Struct </span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleStruct</span>: <span class="title">ExampleProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">"A very simple struct."</span></div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</div><div class="line">        simpleDescription += <span class="string">" (adjusted)."</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> b = <span class="type">SimpleStruct</span>()</div><div class="line">b.adjust()</div><div class="line"><span class="keyword">let</span> bDescription = b.simpleDescription</div><div class="line"><span class="comment">//Enum</span></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SimpleEnum</span>: <span class="title">ExampleProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> test(<span class="type">String</span>)</div><div class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .test(text):</div><div class="line">                <span class="keyword">return</span> text</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">return</span> <span class="string">"A very simiple Enum."</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">" Now (adjusted)."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="built_in">c</span> = <span class="type">SimpleEnum</span>.test(<span class="string">"hello"</span>)</div><div class="line"><span class="built_in">c</span>.simpleDescription</div><div class="line"><span class="built_in">c</span>.adjust()</div></pre></td></tr></table></figure>
<p>注意使用 <code>mutating</code>关键字来声明在 <code>SimpleStructure</code>中使方法可以修改结构体。在 <code>SimpleClass</code>中则不需要这样声明，因为<strong>类</strong>里的方法总是可以<strong>修改其自身属性</strong>的。</p>
<p><strong>Extension:</strong> 使用 <code>extension</code>来给现存的<strong>类型</strong>增加功能，比如说新的<strong>方法</strong>和<strong>计算属性</strong>。你可以使用扩展来使协议到别处定义类型，或者你导入的其他库或框架。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">ExampleProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"The number <span class="subst">\(<span class="keyword">self</span>)</span>"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">self</span> += <span class="number">42</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="number">7</span>.simpleDescription)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> absoluteValue: <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">return</span> fabs(<span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>((-<span class="number">4.2</span>).absoluteValue)</div></pre></td></tr></table></figure>
<p>你可以使用协议名称就像其他命名类型一样——比如说，创建一个拥有不同类型但是都遵循同一个协议的对象的集合。当你操作类型是协议类型的值的时候，协议外定义的方法是不可用的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> protocolValue: <span class="type">ExampleProtocol</span> = a</div><div class="line"><span class="built_in">print</span>(protocolValue.simpleDescription)</div></pre></td></tr></table></figure>
<p>尽管变量 <code>protocolValue</code>有 <code>SimpleClass</code>的运行时类型，但编译器还是把它看做 <code>ExampleProtocol</code>。这意味着你<strong>不能访问类</strong>在这个协议中<strong>扩展</strong>的<strong>方法</strong>或者<strong>属性</strong></p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>你可以用任何遵循 <code>Error</code> 协议的类型来表示错误。使用 <code>throw</code> 来抛出一个错误并且用 <code>throws</code> 来标记一个可以抛出错误的<strong>函数</strong>。如果你在函数里抛出一个错误，函数会立即返回并且调用函数的代码会处理错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PrinterError</span>: <span class="title">Error</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> outOfPaper</div><div class="line">    <span class="keyword">case</span> noToner</div><div class="line">    <span class="keyword">case</span> onFire</div><div class="line">&#125;</div><div class="line">hrow 来抛出一个错误并且用 <span class="keyword">throws</span> 来标记一个可以抛出错误的函数。如果你在函数里抛出一个错误，函数会立即返回并且调用函数的代码会处理错误。</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(job: Int, toPrinter printerName: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">if</span> printerName == <span class="string">"Never Has Toner"</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="type">PrinterError</span>.noToner</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Job sent"</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(job: Int, toPrinter printerName: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">if</span> printerName == <span class="string">"Never Has Toner"</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="type">PrinterError</span>.noToner</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Job sent"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有好几种方法来处理错误。一种是使用 <code>do-catch</code> 。<br>处理方式1：在 <code>do</code> 代码块里，你用 <code>try</code> 来在能抛出错误的函数前标记。在 <code>catch</code> 代码块，<strong>错误会自动赋予名字</strong> <code>error</code> ，如果你不给定其他名字的话。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> printerResponse = <span class="keyword">try</span> send(job: <span class="number">1040</span>, toPrinter: <span class="string">"Bei jing"</span>)<span class="comment">//or "Never Has Toner"</span></div><div class="line">    <span class="built_in">print</span>(printerResponse) <span class="comment">//Bei jing</span></div><div class="line">&#125; <span class="keyword">catch</span> &#123;</div><div class="line">    <span class="built_in">print</span>(error) <span class="comment">//PrinterError.noToner</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>处理方式2：你可以提供多个 <code>catch</code> 代码块来处理特定的错误。你可以在 <code>catch</code> 后写一个模式，用法和 <code>switch</code> 语句里的 <code>case</code> 一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//catch 模式匹配</span></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> printerResponse = <span class="keyword">try</span> send(job: <span class="number">1110</span>, toPrinter: <span class="string">"Gutenberg"</span>)</div><div class="line">    <span class="built_in">print</span>(printerResponse)</div><div class="line">&#125; <span class="keyword">catch</span> <span class="type">PrinterError</span>.onFire &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"I`ll just put this over here, with the rest of the fire."</span>)</div><div class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> printerError <span class="keyword">as</span> <span class="type">PrinterError</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Printer error: <span class="subst">\(printerError)</span>."</span>)</div><div class="line">&#125; <span class="keyword">catch</span> &#123;</div><div class="line">    <span class="built_in">print</span>(error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>处理方式3：另一种处理错误的方法是使用 <code>try?</code> 来转换结果为可选项。如果函数抛出了错误，那么错误被忽略并且结果为 <code>nil</code> 。否则，结果是一个包含了函数<strong>返回值的可选项</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> printerSuccess = <span class="keyword">try</span>? send(job: <span class="number">1882</span>, toPrinter: <span class="string">"Mergenthaler"</span>) <span class="comment">//Job sent</span></div><div class="line"><span class="keyword">let</span> printerFailure = <span class="keyword">try</span>? send(job: <span class="number">1002</span>, toPrinter: <span class="string">"Never Has Toner"</span>) <span class="comment">//nil</span></div></pre></td></tr></table></figure>
<p><strong>defer</strong>: 使用 <code>defer</code> 来写在函数返回之前最后要执行的代码块，无论是否错误被抛出。你甚至可以在没有错误处理的时候使用 <code>defer</code> ，来简化需要在多处地方返回的函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fridgeIsOpen = <span class="literal">false</span></div><div class="line"><span class="keyword">let</span> fridgeContent = [<span class="string">"milk"</span>, <span class="string">"eggs"</span>, <span class="string">"leftovers"</span>]</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fridgeContains</span><span class="params">(<span class="number">_</span> food: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    fridgeIsOpen = <span class="literal">true</span> <span class="comment">//1</span></div><div class="line">    <span class="keyword">defer</span> &#123;</div><div class="line">        fridgeIsOpen = <span class="literal">false</span> <span class="comment">//3</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> result = fridgeContent.<span class="built_in">contains</span>(food) <span class="comment">//2</span></div><div class="line">    <span class="keyword">return</span> result <span class="comment">//4</span></div><div class="line">&#125;</div><div class="line">fridgeContains(<span class="string">"banana"</span>)</div><div class="line"><span class="built_in">print</span>(fridgeIsOpen) <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>把名字写在尖括号里来创建一个<strong>泛型方法</strong>或者<strong>类型</strong>。<br>泛型<strong>方法</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeArray</span>&lt;Item&gt;<span class="params">(repeating item: Item, numberOfTimes: Int)</span></span> -&gt; [<span class="type">Item</span>] &#123;</div><div class="line">    <span class="keyword">var</span> result = [<span class="type">Item</span>]()</div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;numberOfTimes &#123;</div><div class="line">        result.append(item)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line">makeArray(repeating: <span class="string">"knock"</span>, numberOfTimes: <span class="number">4</span>)</div></pre></td></tr></table></figure>
<p>泛型<strong>枚举、结构体</strong>创建泛型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OptionalValue</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="keyword">none</span></div><div class="line">    <span class="keyword">case</span> some(<span class="type">Wrapped</span>)</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">Any</span> &#123;</div><div class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">        <span class="keyword">case</span> .<span class="keyword">none</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .some(val):</div><div class="line">            <span class="keyword">return</span> val</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> possibleInteger: <span class="type">OptionalValue</span>&lt;<span class="type">Int</span>&gt; = .<span class="keyword">none</span></div><div class="line">possibleInteger.simpleDescription()</div><div class="line">possibleInteger = .some(<span class="number">100</span>)</div></pre></td></tr></table></figure>
<p><strong>where：</strong>在类型名称后紧接 <code>where</code>来明确一系列需求——比如说，来要求类型实现一个协议，要求两个类型必须相同，或者要求类必须继承自特定的父类。写<code>&lt;T: Equatable&gt;</code>和 <code>&lt;T where T: Equatable&gt;</code>是同一回事</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyCommonElements</span>&lt;T: Sequence, U:Sequence&gt;<span class="params">(<span class="number">_</span> lhs: T, <span class="number">_</span> rhs: U)</span></span> -&gt; <span class="type">Bool</span> <span class="keyword">where</span> <span class="type">T</span>.<span class="type">Iterator</span>.<span class="type">Element</span>: <span class="type">Equatable</span>, <span class="type">T</span>.<span class="type">Iterator</span>.<span class="type">Element</span> == <span class="type">U</span>.<span class="type">Iterator</span>.<span class="type">Element</span> &#123;</div><div class="line">    <span class="keyword">for</span> lhsItem <span class="keyword">in</span> lhs &#123;</div><div class="line">        <span class="keyword">for</span> rhsItem <span class="keyword">in</span> rhs &#123;</div><div class="line">            <span class="keyword">if</span> lhsItem == rhsItem &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>摘自：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" target="_blank" rel="external">swift 官网</a><br>所有代码在Xcode9 Swift4 环境编译没问题，代码<a href="https://github.com/keshiim/LearnSwift4" target="_blank" rel="external">戳这里 https://github.com/keshiim/LearnSwift4</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://keshiim.github.io/2017/09/12/topVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng keshiim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Farmer, keshiim 播种太阳🌞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/12/topVC/" itemprop="url">iOS 获取当前正在显示的ViewController</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-12T12:13:13+08:00">
                2017-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/12/topVC/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/09/12/topVC/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/09/12/topVC/" class="leancloud_visitors" data-flag-title="iOS 获取当前正在显示的ViewController">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="iOS-获取当前正在显示的ViewController-方法有如下几种"><a href="#iOS-获取当前正在显示的ViewController-方法有如下几种" class="headerlink" title="iOS 获取当前正在显示的ViewController,方法有如下几种"></a>iOS 获取当前正在显示的ViewController,方法有如下几种</h3><hr>
<h4 id="1-从UIWindow中获取"><a href="#1-从UIWindow中获取" class="headerlink" title="1. 从UIWindow中获取"></a>1. 从UIWindow中获取</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UIWindow+SHHelper.h"</span>  </span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIWindow</span> (<span class="title">SHHelper</span>)  </span></div><div class="line">  </div><div class="line">- (<span class="built_in">UIViewController</span>*)sh_topMostController  </div><div class="line">&#123;  </div><div class="line">    <span class="comment">//  getting rootViewController  </span></div><div class="line">    <span class="built_in">UIViewController</span> *topController = [<span class="keyword">self</span> rootViewController];  </div><div class="line">      </div><div class="line">    <span class="comment">//  Getting topMost ViewController  </span></div><div class="line">    <span class="keyword">while</span> ([topController presentedViewController]) topController = [topController presentedViewController];  </div><div class="line">      </div><div class="line">    <span class="comment">//  Returning topMost ViewController  </span></div><div class="line">    <span class="keyword">return</span> topController;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">- (<span class="built_in">UIViewController</span>*)sh_currentViewController;  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">UIViewController</span> *currentViewController = [<span class="keyword">self</span> sh_topMostController];  </div><div class="line">      </div><div class="line">    <span class="keyword">while</span> ([currentViewController isKindOfClass:[<span class="built_in">UINavigationController</span> <span class="keyword">class</span>]] &amp;&amp; [(<span class="built_in">UINavigationController</span>*)currentViewController topViewController])  </div><div class="line">        currentViewController = [(<span class="built_in">UINavigationController</span>*)currentViewController topViewController];  </div><div class="line">      </div><div class="line">    <span class="keyword">return</span> currentViewController;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="2-从UIView里面获取"><a href="#2-从UIView里面获取" class="headerlink" title="2. 从UIView里面获取"></a>2. 从UIView里面获取</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//满足一个日常的需求:在UITableviewcell里面的UIView模块里面，调用self.navigationcontroller pushviewcontroller推入一个新的viewcontroller，需要获取其上层的UIViewcontroller, 可以使用下面的方法:  </span></div><div class="line">- (<span class="built_in">UIViewController</span> *)sh_viewController  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">UIResponder</span> *responder = <span class="keyword">self</span>;  </div><div class="line">    <span class="keyword">while</span> ((responder = [responder nextResponder]))&#123;  </div><div class="line">        <span class="keyword">if</span> ([responder isKindOfClass: [<span class="built_in">UIViewController</span> <span class="keyword">class</span>]])&#123;  </div><div class="line">            <span class="keyword">return</span> (<span class="built_in">UIViewController</span> *)responder;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-从UIViewController中获取"><a href="#3-从UIViewController中获取" class="headerlink" title="3. 从UIViewController中获取"></a>3. 从UIViewController中获取</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UIViewController+SHHelper.h"</span>  </span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">SHHelper</span>)  </span></div><div class="line">  </div><div class="line">- (<span class="built_in">UIViewController</span>*)sh_topMostController  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">UIViewController</span> *topController = <span class="keyword">self</span> ;  </div><div class="line">      </div><div class="line">    <span class="keyword">while</span> ([<span class="keyword">self</span> presentedViewController])  </div><div class="line">          topController = [topController presentedViewController];  </div><div class="line">      </div><div class="line">    <span class="keyword">return</span> topController;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">- (<span class="built_in">UIViewController</span>*)sh_currentViewController;  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">UIViewController</span> *currentViewController = [<span class="keyword">self</span> sh_topMostController];  </div><div class="line">      </div><div class="line">    <span class="keyword">while</span> ([currentViewController isKindOfClass:[<span class="built_in">UINavigationController</span> <span class="keyword">class</span>]] &amp;&amp; [(<span class="built_in">UINavigationController</span>*)currentViewController topViewController])  </div><div class="line">        currentViewController = [(<span class="built_in">UINavigationController</span>*)currentViewController topViewController];  </div><div class="line">      </div><div class="line">    <span class="keyword">return</span> currentViewController;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">//我们在非视图类中想要随时展示一个view时，需要将被展示的view加到当前view的子视图，或用当前view presentViewController，或pushViewContrller，这些操作都需要获取当前正在显示的ViewController。  </span></div><div class="line"><span class="comment">//获取当前view的UIViewController  </span></div><div class="line">+ (<span class="built_in">UIViewController</span> *)sh_currentViewControllerFromcurrentView&#123;  </div><div class="line">      </div><div class="line">    <span class="built_in">UIViewController</span> *result = <span class="literal">nil</span>;  </div><div class="line">      </div><div class="line">    <span class="comment">// 1. get current window  </span></div><div class="line">    <span class="built_in">UIWindow</span> * window = [[<span class="built_in">UIApplication</span> sharedApplication] keyWindow];  </div><div class="line">    <span class="keyword">if</span> (window.windowLevel != <span class="built_in">UIWindowLevelNormal</span>) &#123;  </div><div class="line">        <span class="built_in">NSArray</span> *windows = [[<span class="built_in">UIApplication</span> sharedApplication] windows];  </div><div class="line">        <span class="keyword">for</span>(<span class="built_in">UIWindow</span> * tempWindow <span class="keyword">in</span> windows) &#123;  </div><div class="line">            <span class="keyword">if</span> (tempWindow.windowLevel == <span class="built_in">UIWindowLevelNormal</span>) &#123;  </div><div class="line">                window = tempWindow;  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="comment">// 2. get current View Controller  </span></div><div class="line">    <span class="built_in">UIView</span> *frontView = [[window subviews] objectAtIndex:<span class="number">0</span>];  </div><div class="line">    <span class="keyword">id</span> nextResponder = [frontView nextResponder];  </div><div class="line">    <span class="keyword">if</span> ([nextResponder isKindOfClass:[<span class="built_in">UIViewController</span> <span class="keyword">class</span>]]) &#123;  </div><div class="line">        result = nextResponder;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        result = window.rootViewController;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> result;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">//获取当前屏幕中present出来的viewcontroller。  </span></div><div class="line">- (<span class="built_in">UIViewController</span> *)getPresentedViewController  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">UIViewController</span> *appRootVC = [<span class="built_in">UIApplication</span> sharedApplication].keyWindow.rootViewController;  </div><div class="line">    <span class="built_in">UIViewController</span> *topVC = appRootVC;  </div><div class="line">    <span class="keyword">if</span> (topVC.presentedViewController) &#123;  </div><div class="line">        topVC = topVC.presentedViewController;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="keyword">return</span> topVC;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Zheng keshiim" />
          <p class="site-author-name" itemprop="name">Zheng keshiim</p>
           
              <p class="site-description motion-element" itemprop="description">一个☝程序猿的播种天地</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">45</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/keshiim" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/Jasonzhengkeshi" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1997859257" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/jason-zheng-17/activities" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng keshiim</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://keshiim.disqus.com/count.js" async></script>
    

    

  




	





  








  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("II40xJrcdEwAMUcs8t0GQCM7-gzGzoHsz", "6u6FB7dghxObIE4zhaUKCYoF");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
